# The parser for Flabbergast is constructed by assembly of small parser
# combinators that are rendered into a parser in the target language. This
# describes the interface expected.
parser_tmpl : Template {
	# Match a literal string, exactly as provided.
	exact : Template { word ?: }
	# Match another parse element, but, if parsing fails, back up the parser and
	# continue to the next rule.
	optional : Template { of ?: }
	# Match a list of parse elements, in order.
	sequence : Template { of ?: }
	# Match a parse element many times, with the provided separator in between
	# each element. That is, parse a list of the form `e,e,e` where `e` is the
	# element and `s` is the separator. The `nonempty` Boolean insists that there
	# is at least one element parsed, otherwise, an empty is list is valid.
	many : Template { of ?:  separator : Null  nonempty : False }
	many_word : Template many {
		separator_word ?:
		separator : exact { word : separator_word }
	}
	# Parses the elements provided in succession, succeeding if any one succeeds
	# and failing if all fail.
	alternate : Template { of ?: }
	# Parses a single character in the range of characters provided. 
	range : Template { from ?:  to ?: }
	# Parses a single character, as indicated.
	single : Template {
		# A string of characters where the parser may match any single character in
		# the string.
		char ?:
		# If true, parsing will succeed if the current character is not in the
		# string defined in `char`.
		invert_match : False
	}
	# Parses sub rules and uses their values to compute an integer.
	accumulate_integer : Template {
		# Each successful rule where `accumulate` is true will have the current
		# input character applied to the accumulator.
		accumulate : False
		# The initial value of the accumulator.
		initial : 0
		# The multiplier is the base of the number used. At each character, the
		# existing value will be multiplied by the supplied multiplier before the
		# new value is added.
		multiplier %:
		# The character will have the provided offset subtracted from the current
		# character before adding it to the accumulator.
		offset %:
		# After successful parsing, the value is stored in the desired field.
		field ?:
		in ?:
	}
	# This works much like `accumulate_integer` except the integer is a Unicode
	# codepoint added to the currently accumulated string.
	accumulate_unichar_integer : Template {
		# Each successful rule where `accumulate` is true will have the current
		# input character applied to the accumulator.
		accumulate : False
		# The initial value of the accumulator.
		initial : 0
		# The multiplier is the base of the number used. At each character, the
		# existing value will be multiplied by the supplied multiplier before the
		# new value is added.
		multiplier %:
		# The character will have the provided offset subtracted from the current
		# character before adding it to the accumulator.
		offset %:
		in ?:
	}
	accumulate_float : Template { accumulate : False  field ?:  in ?: }
	accumulate_list : Template { accumulate : False  field ?: type ?:  in ?: }
	accumulate_string : Template { accumulate : False  field ?:  in ?: }
	accumulate_char : Template { accumulate : False  field ?:  in ?: }
	# Adds a Unicode literal, by codepoint, to the currently accumulating string
	# after successfully parsing the child parse expression.
	collect_codepoint : Template { codepoint ?:  in ?: }
	# Parses another rule
	other : Template {
		# This it the name (and therefore type) of the desired rule to parse.
		type ?:
		# Some rules have many possible AST nodes that they can generate. In some
		# instances, it is desirable to parse only subsets of those possible AST
		# nodes. Rules may then define groups of AST nodes as “alternate” versions
		# of the rule, which will produce the same type, but a different possible
		# subset of values. If specified, this selects one of the predefined
		# subsets. The name of any given AST node is also valid.
		alternate : Null
		# The field in which to place the result. If `Null`, it will be added to
		# the current list.
		field ?:
	}

}
# The syntax of the Flabbergast language
language_tmpl : Template {
	# The templates to generate the parser, as per `parser_tmpl`.
	parser %:
	# A rule that creates a single node in the AST
	syntax_element : Template {
		# The name of AST node. This will be provided by the attribute name. In a
		# parser generated targeting an object-oriented language, this would be the
		# name of the class for each different element in the syntax tree.
		rule_name %:
		# The name of the group of rules. In a parser generated targeting an
		# object-oriented language, this would be the abstract super-class of a
		# collection of rules.
		group_name %:
		# The parser generator structure, made from `parser` templates.
		pattern ?:
	}
	# A group of syntax rules that form a logical group of syntax elements. These
	# should correspond to the single-letter production rules in the
	# specification.
	syntax_group : Template {
		rules : Template {}
		# For the attribute rules, some times, we need to package the same rules in
		# different ways. The alternatives provide names for parsing different
		# groups with the same type as the syntax group.
		alternatives : Template {}
		# This moves fields from the individual AST nodes to the superclass. Each
		# entry is the name of the field and its type (e.g., `name : $str`).
		common : Template {}
		expanded_rules :
			For rule_tmpl : rules {}, rule_name : Attribute
			Select rule_name : rule_tmpl {}
		expanded_alts : alternatives {}
		expanded_common : common {}
	}

	# TODO: make this parse spaces and comments and put the comments in a buffer
	space : Template parser.alternate {
	}
	valid_identifier : Template parser.accumulate_string {
		accumulate : True
		in : parser.sequence {
			of : [
				parser.range { from : "a"  to : "z" },
				parser.many {
					of : parser.alternate {
						of : [
							parser.range { from : "a"  to : "z" },
							parser.range { from : "A"  to : "Z" },
							parser.range { from : "0"  to : "9" },
							parser.single { char : "_" }
						]
					}
				}
			]
		}
	}

	expanded_groups :
		For rule_group_tmpl : rule_groups {}, group_name : Attribute
		Select group_name : rule_group_tmpl {}

	# Syntax element for expressions
	expression_tmpl : Template syntax_element {
		# The depth/precedence in the expression nesting system, as inferred from
		# the specification.
		level %:
		# A parser for an expression one level more nested.
		child_expression : Template parser.other { accumulate : True  type : "expression" & (level + 1) }
		# A parser for an expression of the same level.
		sibling_expression : Template parser.other { accumulate : True  type : "expression" & level }
	}
	# An expression with two operands separated by a token
	binary_operator : Template expression_tmpl {
		# A string which is the separating token
		operator ?:
		# A template for the right-hand operand, normally a child expression.
		right_operand : Template child_expression { }
		pattern : parser.sequence {
			of : [
				child_expression { field : $left },
				space { preferred : True },
				parser.exact { word : operator },
				space { preferred : True },
				right_operand { field : $right }
				]
		}
	}
	# A unary expression preceded by a token
	unary_tmpl : Template expression_tmpl  {
		# A string which precedes the expression
		operator ?:
		pattern : parser.sequence {
			of : [
				parser.exact { word : operator },
				space { },
				child_expression { field : $expr }
			]
		}
	}
	# A expression which is a single word
	literal_tmpl : Template expression_tmpl {
		level : 19
		name ?:
		pattern : parser.exact { word : name }
	}
	# A “long” expression (i.e., one containing many terms)
	long_expression_tmpl : Template expression_tmpl {
		# The type of the terms to collect
		term_type ?:
		pattern : parser.sequence {
			of : [
				child_expression { field : $start_expr },
				parser.accumulate_list {
					field : $terms
					in : parser.many {
						of : parser.other {
							type : term_type
							accumulate : True
							field : Null
						}
					}
				}
			]
		}
	}
	# A right-hand term in “long” expression
	term_tmpl : Template expression_tmpl {
		# The precedence level of the term's enclosing expression.
		level %:
		# The symbol that separates the term.
		symbol ?:
		pattern : parser.sequence {
			of : [
				space { preferred : True },
				parser.exact { word : symbol },
				space { preferred : True },
				child_expression { field : $expression }
			]
		}
	}
	# A decimal number with no preceding zeros.
	valid_number : Template parser.alternate {
		multiplier : 10
		offset : 48
		of : [
			parser.exact { word : "0" },
			parser.sequence {
				of : [
					parser.range { from : "1"  to : "9"  accumulate : True },
					parser.many {
						of : parser.range { from : "0"  to : "9"  accumulate : True }
					}
				]
			}
		]
	}

	# A single hexidecimal digit
	hex_digit : Template parser.alternate {
		multiplier : 16
		of : [
			parser.range {
				offset : 48
				accumulate : True
				from : "0"  to : "9"
			},
			parser.range {
				offset: 87
				accumulate : True
				from : "a"  to : "f"
			},
			parser.range {
				offset : 55
				accumulate : True
				from : "A"  to : "F"
			}
		]
	}
	int_with_unit_tmpl : Template syntax_element {
		symbol ?:
		unit ?:
		pattern : parser.optional {
			of : parser.sequence {
				of : [
					parser.accumulate_integer {
						in : valid_number {}
						field : $count
					}, parser.exact { word : symbol }
				]
			}
		}
	}

	# All the groups in the language. For details, see the specification.
	rule_groups : Template {
		file : Template syntax_group {
			rules +: {
				file : Template syntax_element {
					pattern : accumulate_list {
						in : parser.many {
							of : parser.other {
								type : $attribute
								alternate : $plain_attribute
								field : Null
							}
							nonempty : True
						}
					}
				}
			}
		}

		attribute : Template syntax_group {
			alternatives +: {
				literal_attributes : [ plain_attribute ]
				new_tmpl_attributes : [ plain_attribute, informative_attribute, missing_attribute ]
				extend_tmpl_attributes : [ plain_attribute, informative_attribute, missing_attribute, named_override, template_override, remove_attribute ]
				instantiate_tmpl_attributes : [ plain_attribute, informative_attribute, named_override, template_override, remove_attribute ]
				fricasee_attributes :  [ plain_attribute, ordinal_attribute, name_attribute ]
			}
			common +: {
				name : $str
			}
			rules +: {
				plain_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifer { field : $name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other {
								type : $expression
								alternate : $expression0
								field : $expression
							}
						]
					}
				}
				named_override : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifer { field : $name },
							space { preferred : True },
							parser.exact { word : "+" },
							valid_identifer { field : $temporary_name },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other {
								type : $expression
								alternate : $expression0
								field : $expression
							}
						]
					}
				}
				template_override : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							identifer,
							space { preferred : True },
							parser.exact { word : "+:" },
							space { preferred : True },
							parser.exact { word : "{" },
							space { preferred : True },
							parser.accumulate_list {
								field : $overrides
								in : parser.many {
									of : parser.other {
										type : $attribute
										alternate : $extend_tmpl_attributes
										field : Null
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" },
							space { preferred : True },
						]
					}
				}
				missing_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifer { field : $name },
							space { preferred : True },
							parser.exact { word : "?:" }
						]
					}
				}
				informative_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifer { field : $name },
							space { preferred : True },
							parser.exact { word : "%:" }
						]
					}
				}
				remove_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifer { field : $name },
							space { preferred : True },
							parser.exact { word : "-:" }
						]
					}
				}
				name_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifer { field : $name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.exact { word : "Name" }
						]
					}
				}
				ordinal_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifer { field : $name },
							space { preferred : True },
							parser.exact { char : ":" },
							space { preferred : True },
							parser.exact { word : "Ordinal" }
						]
					}
				}
			}
		}

		ordering : Template syntax_group {
			rules +: {
				order_by : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Order" },
							space { mandatory : True },
							parser.exact { word : "By" },
							space { mandatory : True },
							parser.other {
								type: $expression
								alternate: $expression0
								field : $expression
							}
						]
					}
				}
				reverse : Template literal_tmpl { word : "Reverse" }
			}
		}

		result : Template syntax_group {
			rules +: {
				reduce : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.accumulate_list {
								type : $ordering
								in : parser.many {
									of : parser.other { type: $ordering  field : Null }
								}
							},
							space { mandatory : True },
							parser.exact { word : "Reduce" },
							parser.other { type: $expression  alternative : $expression0 field : $reduce_expr },
							space { mandatory : True },
							parser.exact { word : "With" },
							space { mandatory : True },
							valid_identifer { field : $initial_name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other { type: $expression  alternative : $expressionTODO field : $initial_expr }
						]
					}
				}
				anonymous_select : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Select" },
							space { preferred : True },
							parser.other { type: $expression  alternative : $expressionTODO field : $expression }
						]
					}
				}
				named_select : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Select" },
							space { mandatory : True },
							parser.other { type: $expression  alternative : $expression0 field : $name_expr },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other { type: $expression  alternative : $expressionTODO field : $value_expr }
						]
					}
				}
			}
		}

		selector : Template syntax_group {
			rules +: {
				each : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Each" },
							space { preferred : True },
							parser.other { type: $expression  alternative : $expression0 field : $expression }
						]
					}
				}
				attr_merge : Template syntax_element {
					pattern : parser.accumulate_list {
						field : $inputs
						type : $attribute
						in : parser.many_word {
							of : parser.other {
								type : $attribute
								alternative : $fricasee_attributes
								field : Null
							}
							separator_word : ","
						}
					}
				}
			}
		}

		type : Template syntax_group {
			type_element : Template syntax_element {
				friendly_name ?:
				pattern : parser.exact { word : friendly_name }
			}
			rules +: {
				bool : Template type_element { friendly_name : "Bool" }
				float : Template type_element { friendly_name : "Float" }
				int : Template type_element { friendly_name : "Int" }
				str : Template type_element { friendly_name : "Str" }
				tmpl : Template type_element { friendly_name : "Template" }
				tuple : Template type_element { friendly_name : "Tuple" }
			}
		}

		time : Template syntax_group {
			rules +: {
				days : Template int_with_unit_tmpl { symbol "d"  unit : 60 * 60 * 24 }
				hours : Template int_with_unit_tmpl { symbol "h"  unit : 60 * 60 }
				minutes : Template int_with_unit_tmpl { symbol "m"  unit : 60 }
				seconds : Template int_with_unit_tmpl { symbol "s"  unit : 1 }
			}
		}

		string_piece : Template syntax_group {
			string_escape_tmpl : Template parser.collect_codepoint {
				char ?:
				in : parser.exact { word : "\\" & char }
			}
			rules +: {
				literal_string : Template syntax_element {
					pattern : parser.accumulate_string {
						field : $text
						in : parser.alternate {
							of : [
								string_escape_tmpl { char : "a"  codepoint : 7 },
								string_escape_tmpl { char : "b"  codepoint : 8 },
								string_escape_tmpl { char : "f"  codepoint : 12 },
								string_escape_tmpl { char : "n" codepoint : 10 },
								string_escape_tmpl { char : "r" codepoint : 13 },
								string_escape_tmpl { char : "t" codepoint : 9 },
								string_escape_tmpl { char : "v"  codepoint : 11 },
								string_escape_tmpl { char : "\""  codepoint : 34 },
								string_escape_tmpl { char : "\\"  codepoint : 92 },
								parser.accumulate_unichar_integer {
									multiplier : 8
									offset : 48
									in : parser.sequence {
										of : [
											parser.exact { word : "\\" },
											parser.range { from : "0"  to : "7"  accumulate : True},
											parser.range { from : "0"  to : "7"  accumulate : True},
											parser.range { from : "0"  to : "7"  accumulate : True}
										]
									}
								},
								parser.accumulate_unichar_integer {
									in : parser.sequence {
										of : [
											parser.exact { word : "\\x" },
											hex_digit { },
											hex_digit { }
										]
									}
								},
								parser.accumulate_unichar_integer {
									in : parser.sequence {
										of : [
											parser.exact { word : "\\u" },
											hex_digit { },
											hex_digit { },
											hex_digit { },
											hex_digit { }
										]
									}
								},
								parser.single { char : "\\\""  invert_match : True }
							]
						}
					}
				}
				expression_escape : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\(" },
							space { },
							parser.other {
								type : $expression
								alternate : $expression0
								field : $expression
							},
							space { },
							parser.exact { word : ")" }
						]
					}
				}
			}
		}

		identifierish : Template syntax_group {
			rules +: {
				literal_identifier : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { },
							valid_identifier { field : $name }
						]
					}
				}
				container : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { },
							parser.exact { word : "Container" }
						]
					}
				}
			}
		}

		arithmetic_disjunction_term : Template syntax_group {
			level : 8
			rules +: {
				addition_term : Template term_tmpl {
					symbol : "+"
				}
				subtraction_term : Template term_tmpl {
					symbol : "-"
				}
			}
		}

		arithmetic_conjunction_term : Template syntax_group {
			level : 9
			rules +: {
				multiplication_term : Template term_tmpl {
					symbol : "*"
				}
				division_term : Template term_tmpl {
					symbol : "/"
				}
				modulus_term : Template term_tmpl {
					symbol : "%"
				}
			}
		}

	}
}
