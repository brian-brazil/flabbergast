# The parser for Flabbergast is constructed by assembly of small parser
# combinators that are rendered into a parser in the target language. This
# describes the interface expected.
parser_tmpl : Template {
	# Match a literal string, exactly as provided.
	exact : Template { word ?: }
	# Match another parse element, but, if parsing fails, back up the parser and
	# continue to the next rule.
	optional : Template { of ?: }
	# Match a list of parse elements, in order.
	sequence : Template { of ?: }
	# Match a parse element many times, with the provided separator in between
	# each element. That is, parse a list of the form `e,e,e` where `e` is the
	# element and `s` is the separator. The `nonempty` Boolean insists that there
	# is at least one element parsed, otherwise, an empty is list is valid.
	many : Template { of ?:  separator : Null  nonempty : False }
	many_word : Template many {
		separator_word ?:
		separator : exact { word : separator_word }
	}
	# Parses the elements provided in succession, succeeding if any one succeeds
	# and failing if all fail.
	alternate : Template { of ?: }
	# Parses a single character in the range of characters provided.
	range : Template { from ?:  to ?: }
	# Parses a single character, as indicated.
	single : Template {
		# A string of characters where the parser may match any single character in
		# the string.
		char ?:
		# If true, parsing will succeed if the current character is not in the
		# string defined in `char`.
		invert_match : False
	}
	# Matches any character by Unicode class.
	char_class : Template {
		# A list of character classes to match
		classes ?:
		# If true, parsing will succeed if the current character is not in the
		# any of the character classes enabled.
		invert_match : False

		letter_lower %:
		letter_modifier %:
		letter_other %:
		letter_title %:
		letter_upper %:
		mark_combining %:
		mark_enclosing %:
		mark_nonspace %:
		number_decimal %:
		number_letter %:
		number_other %:
		other_control %:
		other_format %:
		other_private %:
		other_surrogate %:
		other_unassigned %:
		punctuation_connector %:
		punctuation_dash %:
		punctuation_end %:
		punctuation_final_quote %:
		punctuation_initial_quote %:
		punctuation_other %:
		punctuation_start %:
		separator_line %:
		separator_paragraph %:
		separator_space %:
		symbol_currency %:
		symbol_math %:
		symbol_modifier %:
		symbol_other %:
	}
	# Checks that the next character is not one of the specified characters, but does not consume it.
	except : Template {
		# A string with characters to match
		char ?:
	}
	# Parses sub rules and uses their values to compute an integer.
	accumulate_integer : Template {
		# Each successful rule where `accumulate` is true will have the current
		# input character applied to the accumulator.
		accumulate : False
		# The initial value of the accumulator.
		initial : 0
		# The multiplier is the base of the number used. At each character, the
		# existing value will be multiplied by the supplied multiplier before the
		# new value is added.
		multiplier %:
		# The character will have the provided offset subtracted from the current
		# character before adding it to the accumulator.
		offset %:
		# After successful parsing, the value is stored in the desired field.
		field ?:
		in ?:
	}
	# This works much like `accumulate_integer` except the integer is a Unicode
	# codepoint added to the currently accumulated string.
	accumulate_unichar_integer : Template {
		# Each successful rule where `accumulate` is true will have the current
		# input character applied to the accumulator.
		accumulate : False
		# The initial value of the accumulator.
		initial : 0
		# The multiplier is the base of the number used. At each character, the
		# existing value will be multiplied by the supplied multiplier before the
		# new value is added.
		multiplier %:
		# The character will have the provided offset subtracted from the current
		# character before adding it to the accumulator.
		offset %:
		in ?:
	}
	accumulate_float : Template { accumulate : False  field ?:  in ?: }
	accumulate_list : Template { accumulate : False  field ?:  type ?:  in ?: }
	accumulate_string : Template { accumulate : False  field ?:  in ?: }
	# Adds a Unicode literal, by codepoint, to the currently accumulating string
	# after successfully parsing the child parse expression.
	collect_codepoint : Template { codepoint ?:  in ?: }
	# Parses another rule
	other : Template {
		# This it the name (and therefore type) of the desired rule to parse.
		type ?:
		# Some rules have many possible AST nodes that they can generate. In some
		# instances, it is desirable to parse only subsets of those possible AST
		# nodes. Rules may then define groups of AST nodes as “alternate” versions
		# of the rule, which will produce the same type, but a different possible
		# subset of values. If specified, this selects one of the predefined
		# subsets. The name of any given AST node is also valid.
		alternate : Null
		# The field in which to place the result. If `Null`, it will be added to
		# the current list.
		field ?:
	}

}
# Environments are domains in which lookups always yield the same value. They
# are used to break generated code into chunks where lookups occur only in the
# boundaries between chunks. Each syntax element inherits an environment from
# the containing element and then applies it to its children, if any.
#
# Different parts of the code have different semantics, so there are different
# flavours of environment application.
environment_tmpl : Template {
	# A template for all the actions (i.e., things which can be done with an
	# environment).
	application_action : Template {
		# The flavour for which this action should be applied. If the flavour is
		# not matched, this action is ignored.
		flavour : flavour_simple
	}
	# Apply environment to other syntax elements that support environments.
	other_elements : Template application_action {
		# A list of fields to absorb the current environment
		fields ?:
		# The flavour that should be applied. Normally the current flavour.
		target_flavour : flavour
	}
	# Apply environment to all the other syntax elements in a list.
	list_of : Template application_action {
		# The field containing the list.
		field ?:
		# The flavour that should be applied. Normally the current flavour.
		target_flavour : flavour
	}
	# Apply an *independent* environment for each of the other syntax elements in
	# a list.
	list_independent : Template application_action {
		# The field containing the list of elements.
		field ?:
		# Whether to start with a blank environment or derive from the current environment.
		inherit : False
		# The flavour that should be applied. Normally the current flavour.
		target_flavour : flavour
	}
	# Create an empty environment that does not inherit from the current environment.
	blank_environment : Template application_action {
		# A list of actions to perform using this new environment.
		apply_to ?:
	}
	modified_environment : Template application_action {
		# A list of actions to perform using this new environment.
		apply_to ?:
		# If true, unmasked lookups are done in the parent environment. This is
		# used for Let-like behaviour. Normally, lookups in a child environment are
		# independent, so anything “learnt” in the child environment does not apply
		# to the parent. In certain cases, including Let, things learnt about
		# masked names is not applicable, but things learnt about other names is
		# applicable to the parent, so this copies that information back into the
		# parent.
		force_back : False
		# A list of mask collectors that extract names to be changed in the new
		# environment. Masks are backed by real expressions, so information about
		# them can translate to the rest of the syntax tree.
		masks : []
		# A list of free name collectors to be changed in the new environment. Free
		# names, like masks, are different in the child from the parent, but unlike
		# masks, they are not backed by real syntax elements.
		free_names : []

		# Create masks for all the attributes in a list.
		masks_from_attributes : Template {
			# The field containing the list of attributes.
			field ?:
		}
		# Create mask from a name and expression.
		mask_from_fields : Template {
			# The field containing the name to mask.
			name_field ?:
			# The field containing the expression to mask.
			expr_field ?:
		}
		# Create free names from the names of attributes in a list.
		free_names_from_attributes : Template {
			# The field containing the list of attributes.
			field ?:
		}
		# Create a free name from a name.
		free_name_from_field : Template {
			# The field containing the name.
			field ?:
		}
	}
	# Template for the “flavours” of environment.
	flavour_tmpl : Template {
		# Whether this flavour needs to propagate environments.
		enabled ?:
	}
	# An environment flavour that does nothing. It has no environment and does
	# not propagate them.
	flavour_none ?:
	# An environment flavour that causes syntax groups to have an environment and
	# participate in environment propagation and type checking.
	flavour_simple ?:
	# An environment flavour that extends `flavour_simple`, but propagates a
	# second type of environment.
	flavour_double ?:
}
# Templates for making common fields in syntax elements. This is so that some parse rules accumulate results in a single field, such as comments.
common_fields_tmpl : Template {
	str : Template { field_name %: }
	int : Template { field_name %: }
	float : Template { field_name %: }
	other : Template { field_name %:  type ?: }
}
# The syntax of the Flabbergast language
language_tmpl : Template {
	# The templates to generate the parser, as per `parser_tmpl`.
	parser %:
	# The templates to generate the common fields, as per `common_fields_tmpl`.
	common_fields %:
	# A rule that creates a single node in the AST
	syntax_element : Template {
		# The name of AST node. This will be provided by the attribute name. In a
		# parser generated targeting an object-oriented language, this would be the
		# name of the class for each different element in the syntax tree.
		rule_name %:
		# The name of the group of rules. In a parser generated targeting an
		# object-oriented language, this would be the abstract super-class of a
		# collection of rules.
		group_name %:
		# The parser generator structure, made from `parser` templates.
		pattern ?:
		# If the syntax group has environment propagation support, this element
		# contains a list of actions to perform, using templates from the
		# `environment` tuple, when the environment is being configured.
		apply_envrionment_to : environment_flavour.enabled &&
			Error "apply_envrionment_to attribute must be overridden in \(rule_name)."
	}
	# A group of syntax rules that form a logical group of syntax elements. These
	# should correspond to the single-letter production rules in the
	# specification.
	syntax_group : Template {
		rules : Template {}
		# For the attribute rules, some times, we need to package the same rules in
		# different ways. The alternatives provide names for parsing different
		# groups with the same type as the syntax group.
		alternatives : Template {}
		# This moves fields from the individual AST nodes to the superclass. Each
		# entry is the name of the field and its type (e.g., `name : $str`).
		common : Template {}
		# If true, a parser will be generated that parses all the rules provided in
		# alphabetical order. Otherwise, only individual rules and alternatives
		# will be avilable for parsing.
		include_base_parser : True
		# The type of syntax checking and name resolution environment associated
		# with this group.
		environment_flavour : environment.flavour_none
		expanded_rules :
			For rule_tmpl : rules {}, rule_name : Name
			Select rule_name : rule_tmpl {}
		expanded_alts : alternatives {}
		expanded_common : For common_tmpl : common {}, field_name : Name
			Select field_name : common_tmpl {}
	}

	# Parse a space and/or comment
	space : Template parser.accumulate_string {
		# Whether there must be some space for successful parsing.
		mandatory : False
		# If `mandatory` is not true, emit a space when pretty printing.
		preferred : False

		field : $comment
		in : parser.many {
			nonempty : mandatory
			of : parser.alternate {
				of : [
					parser.single { char : " \\t\\n\\r\\f\\v" },
					parser.sequence {
						of : [
							parser.exact { word : "#" },
							parser.many {
								of : parser.single { char : "\\n"  invert_match : True  accumulate : True }
							},
							parser.single { char : "\\n" }
						]
					}
				]
			}
		}
	}
	valid_identifier : Template parser.accumulate_string {
		accumulate : True
		in : parser.sequence {
			of : [
				parser.range { from : "a"  to : "z" },
				parser.many {
					of : parser.alternate {
						of : [
							parser.range { from : "a"  to : "z" },
							parser.range { from : "A"  to : "Z" },
							parser.range { from : "0"  to : "9" },
							parser.single { char : "_" }
						]
					}
				}
			]
		}
	}

	expanded_groups :
		For rule_group_tmpl : rule_groups {}, group_name : Name
		Select group_name : rule_group_tmpl {}

	# Syntax element for expressions
	expression_tmpl : Template syntax_element {
		# The depth/precedence in the expression nesting system, as inferred from
		# the specification.
		level ?:
		# A parser for a top-level expression
		top_expression : Template parser.other {
			accumulate : True
			alternate : $expression0
			type : $expression
		}
		# A parser for an expression one level more nested.
		child_expression : Template parser.other {
			accumulate : True
			alternate : "expression" & (level + 1)
			type : $expression
		}
		# A parser for an expression of the same level.
		sibling_expression : Template parser.other {
			accumulate : True
			alternate : "expression" & level
			type : $expression
		}
	}
	# An expression with two operands separated by a token
	binary_operator : Template expression_tmpl {
		# A string which is the separating token
		operator ?:
		# A template for the right-hand operand, normally a child expression.
		right_operand : Template child_expression { }
		apply_envrionment_to : [ environment.other_elements { fields : [ $left, $right ] } ]
		pattern : parser.sequence {
			of : [
				child_expression { field : $left },
				space { preferred : True },
				parser.exact { word : operator },
				space { preferred : True },
				right_operand { field : $right }
				]
		}
	}
	# A binary operator where the right operand is a type.
	type_operator : Template binary_operator {
		apply_envrionment_to : [ environment.other_elements { fields : [ $left ] } ]
		right_operand : Template parser.other {
			type : $type
		}
	}
	# An "Is" operator.
	is_suffix_operator : Template binary_operator {
		suffix ?:
		operator : "Is"
		apply_envrionment_to : [ environment.other_elements { fields : [ $left ] } ]
		right_operand : Template parser.exact { word : suffix }
	}
	# A unary expression preceded by a token
	unary_tmpl : Template expression_tmpl  {
		# A string which precedes the expression
		operator ?:
		apply_envrionment_to : [ environment.other_elements { fields : [ $expr ] } ]
		pattern : parser.sequence {
			of : [
				parser.exact { word : operator },
				space { },
				child_expression { field : $expr }
			]
		}
	}
	# A expression which is a single word
	literal_tmpl : Template expression_tmpl {
		level : 19
		apply_envrionment_to : []
		name ?:
		pattern : parser.exact { word : name }
	}
	int_with_unit_expr_tmpl : Template expression_tmpl {
		level : 19
		unit ?:
		symbol ?:
		pattern : int_with_unit_tmpl {}
		apply_envrionment_to : [ ]
	}
	# A “long” expression (i.e., one containing many terms)
	long_expression_tmpl : Template expression_tmpl {
		# The type of the terms to collect
		term_type ?:
		pattern : parser.sequence {
			of : [
				child_expression { field : $start_expr },
				parser.accumulate_list {
					field : $terms
					type : term_type
					in : parser.many {
						of : parser.other {
							type : term_type
							accumulate : True
							field : Null
						}
					}
				}
			]
		}
		apply_envrionment_to : [
			environment.other_elements { fields : [ $start_expr ] },
			environment.list_of { field : $terms }
		]
	}
	# A right-hand term in “long” expression
	long_term_tmpl : Template syntax_element {
		# The precedence level of the term's enclosing expression.
		level %:
		# The symbol that separates the term.
		symbol ?:
		apply_envrionment_to : [ environment.other_elements { fields : [ $expression ] } ]
		pattern : parser.sequence {
			of : [
				space { preferred : True },
				parser.exact { word : symbol },
				space { preferred : True },
				parser.other {
					accumulate : True
					type : $expression
					alternate : "expression" & (level + 1)
					field : $expression
				}
			]
		}
	}
	# A decimal number with no preceding zeros.
	valid_number : Template parser.alternate {
		multiplier : 10
		offset : 48
		of : [
			parser.exact { word : "0" },
			parser.sequence {
				of : [
					parser.range { from : "1"  to : "9"  accumulate : True },
					parser.many {
						of : parser.range { from : "0"  to : "9"  accumulate : True }
					}
				]
			}
		]
	}

	# A single hexidecimal digit
	hex_digit : Template parser.alternate {
		multiplier : 16
		of : [
			parser.range {
				offset : 48
				accumulate : True
				from : "0"  to : "9"
			},
			parser.range {
				offset: 87
				accumulate : True
				from : "a"  to : "f"
			},
			parser.range {
				offset : 55
				accumulate : True
				from : "A"  to : "F"
			}
		]
	}
	int_with_unit_tmpl : Template parser.sequence {
		symbol %:
		unit %:
		of : [
			parser.accumulate_integer {
				in : valid_number {}
				field : $count
			},
			parser.exact { word : symbol }
		]
	}
	for_pattern : Template parser.sequence {
		selector ?:
		of : [
			parser.exact { word : "For" },
			space { mandatory : True },
			selector { },
			parser.optional {
				of : parser.sequence {
					of : [
						space { mandatory : True },
						parser.exact { word : "Where" },
						space { mandatory : True },
						parser.other {
							type : $expression
							alternate : $expression0
							field : $where_expr
						}
					]
				}
			},
			space { mandatory : True },
			parser.other {
				field : $result_builder
				type : $fricassee_result
			}
		]
	}

	# All the groups in the language. For details, see the specification.
	rule_groups : Template {
		file : Template syntax_group {
			environment_flavour : environment.flavour_simple
			rules +: {
				file : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.accumulate_list {
								field : $attributes
								type : $attribute
								in : parser.many {
									of : parser.other {
										type : $attribute
										alternate : $plain_attribute
										field : Null
									}
									nonempty : True
								}
							},
							space { }
						]
					}
					apply_envrionment_to : [ environment.list_independent { field : $attributes } ]
				}
			}
		}

		attribute : Template syntax_group {
			include_base_parser : False
			environment_flavour : environment.flavour_simple
			common +: {
				comment : common_fields.str
				name : common_fields.str
			}
			alternatives +: {
				new_tmpl_attributes : [ $plain_attribute, $informative_attribute, $missing_attribute ]
				extend_tmpl_attributes : [ $plain_attribute, $informative_attribute, $missing_attribute, $named_override, $template_override, $remove_attribute ]
				instantiate_tmpl_attributes : [ $plain_attribute, $informative_attribute, $named_override, $template_override, $remove_attribute ]
				fricasee_attributes :  [ $plain_attribute, $ordinal_attribute, $name_attribute ]
			}
			rules +: {
				plain_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other {
								type : $expression
								alternate : $expression0
								field : $expression
							}
						]
					}
					apply_envrionment_to : [ environment.other_elements { fields : [ $expression ] } ]
				}
				named_override : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : "+" },
							valid_identifier { field : $temporary_name },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other {
								type : $expression
								alternate : $expression0
								field : $expression
							}
						]
					}
					apply_envrionment_to : [ environment.modified_environment {
						apply_to : [ environment.other_elements { fields : [ $expression ] } ]
						free_names : [ free_name_from_field { field : $name } ]
					} ]
				}
				template_override : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : "+:" },
							space { preferred : True },
							parser.exact { word : "{" },
							parser.accumulate_list {
								field : $overrides
								type : $attribute
								in : parser.many {
									of : parser.other {
										type : $attribute
										alternate : $extend_tmpl_attributes
										field : Null
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" },
							space { preferred : True }
						]
					}
					# TODO new environment for attributes
					apply_envrionment_to : [ ]
				}
				missing_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : "?:" }
						]
					}
					apply_envrionment_to : [ ]
				}
				informative_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : "%:" }
						]
					}
					apply_envrionment_to : [ ]
				}
				remove_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : "-:" }
						]
					}
					apply_envrionment_to : [ ]
				}
				name_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.exact { word : "Name" }
						]
					}
					apply_envrionment_to : [ ]
				}
				ordinal_attribute : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { preferred : True },
							valid_identifier { field : $name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.exact { word : "Ordinal" }
						]
					}
					apply_envrionment_to : [ ]
				}
			}
		}

		fricassee_ordering : Template syntax_group {
			environment_flavour : environment.flavour_simple
			common +: {
				comment : common_fields.str
			}
			rules +: {
				order_by : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Order" },
							space { mandatory : True },
							parser.exact { word : "By" },
							space { mandatory : True },
							parser.other {
								type: $expression
								alternate: $expression0
								field : $expression
							},
							space { mandatory : True }
						]
					}
					apply_envrionment_to : [ environment.other_elements { fields : [ $expression ] } ]
				}
				reverse : Template syntax_element {
					pattern : parser.sequence {
						of : [ parser.exact { word : "Reverse" }, space { mandatory : True } ]
					}
					apply_envrionment_to : []
				}
			}
		}

		fricassee_result : Template syntax_group {
			environment_flavour : environment.flavour_double
			common +: {
				comment : common_fields.str
			}
			rules +: {
				reduce : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.accumulate_list {
								type : $fricassee_ordering
								field : $orderings
								in : parser.many {
									of : parser.other { type: $fricassee_ordering  field : Null }
								}
							},
							parser.exact { word : "Reduce" },
							space { mandatory : True },
							parser.other { type: $expression  alternate : $expression0  field : $reduce_expr },
							space { mandatory : True },
							parser.exact { word : "With" },
							space { mandatory : True },
							valid_identifier { field : $initial_name },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other { type: $expression  alternate : $expression2  field : $initial_expr }
						]
					}
					apply_envrionment_to : [
						environment.other_elements {
							fields : [ $initial_expr ]
							flavour : environment.flavour_double
							target_flavour : environment.flavour_simple
						},
						environment.list_of { field : $orderings },
						environment.modified_environment {
							masks : [ mask_from_fields { name_field : $initial_name  expr_field : $initial_expr } ]
							apply_to : [ environment.other_elements { fields : [ $reduce_expr ] } ]
						}
					]
				}
				anonymous_select : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.accumulate_list {
								type : $fricassee_ordering
								field : $orderings
								in : parser.many {
									of : parser.other { type: $fricassee_ordering  field : Null }
								}
							},
							parser.exact { word : "Select" },
							space { preferred : True },
							parser.other { type: $expression  alternate : $expression2 field : $expression },
							parser.except { char : ":" }
						]
					}
					apply_envrionment_to : [
							environment.list_of { field : $orderings },
							environment.other_elements { fields : [ $expression ] }
						]
				}
				named_select : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Select" },
							space { mandatory : True },
							parser.other { type: $expression  alternate : $expression0 field : $name_expr },
							space { preferred : True },
							parser.exact { word : ":" },
							space { preferred : True },
							parser.other { type: $expression  alternate : $expression2 field : $value_expr }
						]
					}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $name_expr, $value_expr ] }
					]
				}
			}
		}

		type : Template syntax_group {
			type_element : Template syntax_element {
				friendly_name ?:
				pattern : parser.exact { word : friendly_name }
			}
			rules +: {
				bool : Template type_element { friendly_name : "Bool" }
				float : Template type_element { friendly_name : "Float" }
				int : Template type_element { friendly_name : "Int" }
				str : Template type_element { friendly_name : "Str" }
				tmpl : Template type_element { friendly_name : "Template" }
				tuple : Template type_element { friendly_name : "Tuple" }
			}
		}

		time : Template syntax_group {
			time_chunk : Template syntax_element {
				unit ?:
				symbol ?:
				pattern : int_with_unit_tmpl {}
			}
			rules +: {
				days : Template time_chunk { symbol : "d"  unit : 60 * 60 * 24 }
				hours : Template time_chunk { symbol : "h"  unit : 60 * 60 }
				minutes : Template time_chunk { symbol : "m"  unit : 60 }
				seconds : Template time_chunk { symbol : "s"  unit : 1 }
			}
		}

		string_piece : Template syntax_group {
			environment_flavour : environment.flavour_simple
			common +: {
				comment : common_fields.str
			}
			string_escape_tmpl : Template parser.collect_codepoint {
				char ?:
				in : parser.exact { word : "\\\\" & char }
			}
			rules +: {
				literal_string : Template syntax_element {
					pattern : parser.accumulate_string {
						field : $text
						in : parser.alternate {
							of : [
								string_escape_tmpl { char : "a"  codepoint : 7 },
								string_escape_tmpl { char : "b"  codepoint : 8 },
								string_escape_tmpl { char : "f"  codepoint : 12 },
								string_escape_tmpl { char : "n" codepoint : 10 },
								string_escape_tmpl { char : "r" codepoint : 13 },
								string_escape_tmpl { char : "t" codepoint : 9 },
								string_escape_tmpl { char : "v"  codepoint : 11 },
								string_escape_tmpl { char : "\\\""  codepoint : 34 },
								string_escape_tmpl { char : "\\\\"  codepoint : 92 },
								parser.accumulate_unichar_integer {
									multiplier : 8
									offset : 48
									in : parser.sequence {
										of : [
											parser.exact { word : "\\\\" },
											parser.range { from : "0"  to : "7"  accumulate : True},
											parser.range { from : "0"  to : "7"  accumulate : True},
											parser.range { from : "0"  to : "7"  accumulate : True}
										]
									}
								},
								parser.accumulate_unichar_integer {
									in : parser.sequence {
										of : [
											parser.exact { word : "\\\\x" },
											hex_digit { },
											hex_digit { }
										]
									}
								},
								parser.accumulate_unichar_integer {
									in : parser.sequence {
										of : [
											parser.exact { word : "\\\\u" },
											hex_digit { },
											hex_digit { },
											hex_digit { },
											hex_digit { }
										]
									}
								},
								parser.single { char : "\\\\\\\""  invert_match : True }
							]
						}
					}
					apply_envrionment_to : [ ]
				}
				expression_escape : Template syntax_element {
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\\\(" },
							space { },
							parser.other {
								type : $expression
								alternate : $expression0
								field : $expression
							},
							space { },
							parser.exact { word : ")" }
						]
					}
					apply_envrionment_to : [ environment.other_elements { fields : [ $expression ] } ]
				}
			}
		}

		identifier : Template syntax_group {
			common +: {
				comment : common_fields.str
			}
			rules +: {
				literal_identifier : Template syntax_element {
					pattern : parser.sequence {
						of : [
							space { },
							valid_identifier { field : $name }
						]
					}
				}
			}
		}

		arithmetic_disjunction_term : Template syntax_group {
			level : 8
			environment_flavour : environment.flavour_simple
			common +: {
				comment : common_fields.str
			}
			rules +: {
				addition_term : Template long_term_tmpl {
					symbol : "+"
				}
				subtraction_term : Template long_term_tmpl {
					symbol : "-"
				}
			}
		}

		arithmetic_conjunction_term : Template syntax_group {
			level : 9
			environment_flavour : environment.flavour_simple
			common +: {
				comment : common_fields.str
			}
			rules +: {
				multiplication_term : Template long_term_tmpl {
					symbol : "*"
				}
				division_term : Template long_term_tmpl {
					symbol : "/"
				}
				modulus_term : Template long_term_tmpl {
					symbol : "%"
				}
			}
		}

		expression : Template syntax_group {
			include_base_parser : False
			environment_flavour : environment.flavour_simple
			alternatives -:
			expanded_alts : For alt_level : 0 Through 19
				Select "expression\(alt_level)" :
					For rule : expanded_rules, rule_name : Name
					Where If rule.level Is Null Then alt_level < 19 Else rule.level == alt_level
					Select If rule.level Is Null Then "expression\(alt_level + 1)" Else rule_name

			common +: {
				comment : common_fields.str
			}
			rules +: {
				# This is a special rule for expression generation. Since every
				# expression belongs to a precedence level, this rule causes generation
				# of the call to search th enext precedence level. The compiler
				# implementation must supress it to not generate real code and the
				# `expanded_alts` uses it to generate the expression call.
				zzzz_up : Template expression_tmpl {
					level : Null
					apply_envrionment_to : []
					pattern : parser.exact { word : "X" }
				}
				let : Template expression_tmpl {
					level : 0
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Let" },
							space { mandatory : True },
							parser.accumulate_list {
								type : $attribute
								field : $definitions
								in : parser.many_word {
									of : parser.other { type : $attribute  alternate : $plain_attribute  field : Null }
									separator_word : ","
									nonempty : True
								}
							},
							space { mandatory : True },
							parser.exact { word : "In" },
							sibling_expression { field : $expression }
						]
					}
					apply_envrionment_to : [
						environment.list_of { field : $definitions },
						environment.modified_environment {
							force_back : True
							masks : [ masks_from_attributes { field : $definitions } ]
							apply_to : [ environment.other_elements { fields : [ $expression ] } ]
						}
					]
				}


				for_each : Template expression_tmpl {
					level : 1
					pattern : for_pattern {
						selector : Template parser.sequence {
						of : [
							parser.exact { word : "Each" },
							space { preferred : True },
							parser.other { type: $expression  alternate : $expression0 field : $each_expr }
						]
					}

					}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $each_expr ] },
						environment.other_elements { fields : [ $result_builder ]  target_flavour : environment.flavour_double },
						environment.blank_environment {
							apply_to : [
								environment.other_elements { fields : [ $where_expr ] },
								environment.modified_environment {
									apply_to : [ environment.other_elements { fields : [ $result_builder ] } ]
								}
							]
						}
					]
				}
				for_merge : Template expression_tmpl {
					level : 1
					pattern : for_pattern {
						selector : Template parser.accumulate_list {
							field : $inputs
							type : $attribute
							in : parser.many_word {
								of : parser.other {
									type : $attribute
									alternate : $fricasee_attributes
									field : Null
								}
								separator_word : ","
							}
						}
					}
					apply_envrionment_to : [
						environment.list_of { field : $inputs },
						environment.other_elements { fields : [ $result_builder ]  target_flavour : environment.flavour_double },
						environment.modified_environment {
							apply_to : [
								environment.other_elements { fields : [ $where_expr ] },
								environment.modified_environment {
									apply_to : [ environment.other_elements { fields : [ $result_builder ] } ]
								}
							]
							free_names : [ free_names_from_attributes { field : $inputs } ]
						}
					]
				}

				if : Template expression_tmpl {
					level : 2
					pattern : parser.sequence {
						of : [
							parser.exact { word : "If" },
							space { mandatory : True },
							top_expression { field : $cond_expr },
							space { mandatory : True },
							parser.exact { word : "Then" },
							space { mandatory : True },
							top_expression { field : $then_expr },
							space { mandatory : True },
							parser.exact { word : "Else" },
							space { mandatory : True },
							sibling_expression { field : $else_expr }
						]
					}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $cond_expr ] },
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $then_expr ] } ]
						},
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $else_expr ] } ]
						}
					]
				}

				concatenate : Template binary_operator {
					level : 3
					operator : "&"
					right_operand : Template sibling_expression {}
				}

				disjunction : Template binary_operator {
					level : 4
					operator : "||"
					right_operand : Template sibling_expression {}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $left ] },
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $right ] } ]
						}
					]
				}

				conjunction : Template binary_operator {
					level : 5
					operator : "&&"
					right_operand : Template sibling_expression {}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $left ] },
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $right ] } ]
						}
					]
				}

				equality : Template binary_operator {
					level : 6
					operator : "=="
				}
				inequality : Template binary_operator {
					level : 6
					operator : "!="
				}
				greater : Template binary_operator {
					level : 6
					operator : ">"
				}
				greater_or_equality : Template binary_operator {
					level : 6
					operator : ">="
				}
				lesser : Template binary_operator {
					level : 6
					operator : "<"
				}
				lesser_or_equality : Template binary_operator {
					level : 6
					operator : "<="
				}

				compare : Template binary_operator {
					level : 7
					operator : "<=>"
				}

				arithmetic_disjunction : Template long_expression_tmpl {
					level : 8
					term_type : $arithmetic_disjunction_term
				}

				arithmetic_conjunction : Template long_expression_tmpl {
					level : 9
					term_type : $arithmetic_conjunction_term
				}

				range : Template binary_operator {
					level : 10
					operator : "Through"
				}

				coerce : Template type_operator {
					level : 11
					operator : "To"
				}
				enforce : Template type_operator {
					level : 11
					operator : "As"
				}
				check : Template type_operator {
					level : 11
					operator : "Is"
				}
				is_finite : Template is_suffix_operator {
					level : 11
					suffix : "Finite"
				}
				is_nan : Template is_suffix_operator {
					level : 11
					suffix : "NaN"
				}
				is_null : Template is_suffix_operator {
					level : 11
					suffix : "Null"
				}

				error : Template unary_tmpl {
					level : 12
					operator : "Error"
				}
				length : Template unary_tmpl {
					level : 12
					operator : "Length"
				}

				remote_lookup : Template expression_tmpl {
					level : 13
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Lookup" },
							space { mandatory : True },
							parser.accumulate_list {
								type : $identifier
								field : $names
								in : parser.many_word {
									of : parser.other {
										type : $identifier
										field : Null
									}
									separator_word : "."
								}
							},
							space { mandatory : True },
							parser.exact { word : "In" },
							space { mandatory : True },
							sibling_expression { field : $expression }
						]
					}
					apply_envrionment_to : [ environment.other_elements { fields : [ $expression ] } ]
				}

				instantiation : Template expression_tmpl {
					level : 14
					pattern : parser.sequence {
						of : [
							child_expression { field : $source },
							space { preferred : True },
							parser.exact { word : "{" },
							parser.accumulate_list {
								field : $attributes
								type : $attribute
								in : parser.many {
									of : parser.other {
										type : $attribute
										field : Null
										alternate : $instantiate_tmpl_attributes
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" }
						]
					}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $source ] },
						environment.list_independent { field : $attributes }
					]
				}

				coalesce : Template binary_operator {
					level : 15
					operator : "??"
					apply_envrionment_to : [
						environment.other_elements { fields : [ $left ] },
						environment.modified_environment {
							apply_to : [ environment.other_elements { fields : [ $right ] } ]
						}
					]
				}

				literal_tuple : Template expression_tmpl {
					level : 16
					pattern : parser.sequence {
						of : [
							parser.exact { word : "{" },
							space { preferred : True },
							parser.accumulate_list {
								field : $attributes
								type : $attribute
								in : parser.many {
									of : parser.other {
										type : $attribute
										field : Null
										alternate : $plain_attribute
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" }
						]
					}
					apply_envrionment_to : [ environment.list_of { field : $attributes } ]
				}
				not : Template unary_tmpl {
					level : 16
					operator : "!"
				}
				negation : Template unary_tmpl {
					level : 16
					operator : "-"
				}
				generate_id : Template unary_tmpl {
					level : 16
					operator : "GenerateId"
				}
				template_new : Template expression_tmpl {
					level : 16
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Template" },
							space { preferred : True },
							parser.exact { word : "{" },
							parser.accumulate_list {
								field : $attributes
								type : $attribute
								in : parser.many {
									of : parser.other {
										type : $attribute
										field : Null
										alternate : $new_tmpl_attributes
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" }
						]
					}
					apply_envrionment_to : [ environment.list_independent { field : $attributes } ]
				}
				template_extend : Template expression_tmpl {
					level : 16
					pattern : parser.sequence {
						of : [
							parser.exact { word : "Template" },
							space { mandatory : True },
							child_expression { field : $source },
							space { preferred : True },
							parser.exact { word : "{" },
								parser.accumulate_list {
								field : $attributes
								type : $attribute
								in : parser.many {
									of : parser.other {
										type : $attribute
										field : Null
										alternate : $extend_tmpl_attributes
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "}" }
						]
					}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $source ] },
						environment.list_independent { field : $attributes }
					]
				}

				function_anonymous : Template expression_tmpl {
					level : 17
					pattern : parser.sequence {
						of : [
							child_expression { field : $func_expr },
							space { },
							parser.exact { word : "(" },
							parser.accumulate_list {
								field : $args
								type : $expression
								in : parser.many_word {
									of : parser.sequence {
										of : [
											space { preferred : True },
											top_expression { field : Null },
											space { }
										]
									}
									separator_word : ","
								}
							},
							space { },
							parser.exact { word : ")" }
						]
					}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $func_expr ] },
						environment.list_of { field : $args }
					]
				}
				function_named : Template expression_tmpl {
					level : 17
					pattern : parser.sequence {
						of : [
							child_expression { field : $func_expr },
							space { },
							parser.exact { word : "(" },
							parser.accumulate_list {
								field : $args
								type : $attribute
								in : parser.many_word {
									of : parser.sequence {
										of : [
											parser.other {
												type : $attribute
												alternate : $plain_attribute
												field : Null
											},
											space { }
										]
									}
									separator_word : ","
								}
							},
							parser.exact { word : ")" }
						]
					}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $func_expr ] },
						environment.list_of { field : $args }
					]
				}
				function_mixed : Template expression_tmpl {
					level : 17
					pattern : parser.sequence {
						of : [
							child_expression { field : $func_expr },
							space { },
							parser.exact { word : "(" },
							parser.accumulate_list {
								field : $anon_args
								type : $expression
								in : parser.many_word {
									nonempty : True
									of : parser.sequence {
										of : [
											space { preferred : True },
											top_expression { field : Null },
											space { },
											parser.except { char : ":" }
										]
									}
									separator_word : ","
								}
							},
							parser.exact { word : "," },
							parser.accumulate_list {
								field : $named_args
								type : $attribute
								in : parser.many_word {
									nonempty : True
									of : parser.sequence {
										of : [
											parser.other {
												type : $attribute
												alternate : $plain_attribute
												field : Null
											},
											space { }
										]
									}
									separator_word : ","
								}
							},
							parser.exact { word : ")" }
						]
					}
					apply_envrionment_to : [
						environment.other_elements { fields : [ $func_expr ] },
						environment.list_of { field : $anon_args },
						environment.list_of { field : $named_args }
					]
				}

				contextual_lookup : Template expression_tmpl {
					level : 18
					pattern : parser.accumulate_list {
						field : $parts
						type : $identifier
						in : parser.many_word {
							of : parser.other {
								type : $identifier
								field : Null
							}
							separator_word : "."
							nonempty : True
						}
					}
					apply_envrionment_to : []
				}
				from : Template expression_tmpl {
					level : 18
					pattern : parser.sequence {
						of : [
							parser.exact { word : "From" },
							space { mandatory : True },
							parser.accumulate_string {
								field : $uri
								in : parser.sequence {
									accumulate : True
									of : [
										parser.many {
											of : parser.alternate {
												of : [
													parser.range { from : "A"  to : "Z" },
													parser.range { from : "a"  to : "z" },
													parser.range { from : "0"  to : "9" },
													parser.single { char : "-.+" }
												]
											}
										},
										parser.single { char : ":" },
										parser.many {
											of : parser.alternate {
												of : [
													parser.range { from : "A"  to : "Z" },
													parser.range { from : "a"  to : "z" },
													parser.range { from : "0"  to : "9" },
													parser.single { char : "~=-,;!?/.'()[]@$*&#%+" }
												]
											}
										}
									]
								}
							}
						]
					}
					apply_envrionment_to : []
				}
				direct_lookup : Template expression_tmpl {
					level : 18
					pattern : parser.sequence {
						of : [
							child_expression { field : $expr },
							space { },
							parser.exact { word : "." },
							parser.accumulate_list {
								type : $identifier
								field : $names
								in : parser.many_word {
									of : parser.other {
										type : $identifier
										field : Null
									}
									separator_word : "."
									nonempty : True
								}
							}
						]
					}
					apply_envrionment_to : [ environment.other_elements { fields : [ $expr ] } ]
				}

				subexpression : Template expression_tmpl {
					level : 19
					pattern : parser.sequence {
						of : [
							parser.exact { word : "(" },
							space { },
							top_expression { field : $expression },
							space { },
							parser.exact { word : ")" }
						]
					}
					apply_envrionment_to : [ environment.other_elements { fields : [ $expression ] } ]
				}
				literal_list : Template expression_tmpl {
					level : 19
					pattern : parser.sequence {
						of : [
							parser.exact { word : "[" },
							parser.accumulate_list {
								field : $items
								type : $expression
								in : parser.many_word {
									separator_word : ","
									of : parser.sequence {
										of : [
											space { preferred : True },
											top_expression { field : Null },
											space { }
										]
									}
								}
							},
							space { preferred : True },
							parser.exact { word : "]" }
						]
					}
					apply_envrionment_to : [ environment.list_of { field : $items } ]
				}

				container : Template literal_tmpl { name : "Container" }
				false : Template literal_tmpl { name : "False" }
				float_max : Template literal_tmpl { name : "FloatMax" }
				float_min : Template literal_tmpl { name : "FloatMin" }
				id : Template literal_tmpl { name : "Id" }
				infinity : Template literal_tmpl { name : "Infinity" }
				int_max : Template literal_tmpl { name : "IntMax" }
				int_min : Template literal_tmpl { name : "IntMin" }
				nan : Template literal_tmpl { name : "NaN" }
				null : Template literal_tmpl { name : "Null" }
				this : Template literal_tmpl { name : "This" }
				true : Template literal_tmpl { name : "True" }

				time_literal : Template expression_tmpl {
					level : 19
					pattern : parser.accumulate_list {
						field : $parts
						type : $time
						in : parser.many {
							of : parser.other {
								type : $time
								accumulate : True
								field : Null
							}
							nonempty : True
						}
					}
					apply_envrionment_to : [ ]
				}
				integer_literal : Template expression_tmpl {
					level : 19
					pattern : parser.accumulate_integer {
						field : $amount
						in : parser.sequence {
							of : [
								valid_number {},
								parser.except { char : ".eGMkdhms" }
							]
						}
					}
					apply_envrionment_to : [ ]
				}
				hex_integer_literal : Template expression_tmpl {
					level : 19
					pattern : parser.accumulate_integer {
						field : $amount
						in : parser.sequence {
							of : [
									parser.exact { word : "0x" },
									parser.many {
										nonempty : True
										of : hex_digit { }
									}
								]
						}
					}
					apply_envrionment_to : [ ]
				}
				int_k : Template int_with_unit_expr_tmpl { symbol : "k"  unit : 1000 }
				int_m : Template int_with_unit_expr_tmpl { symbol : "M"  unit : 1000 * 1000 }
				int_g : Template int_with_unit_expr_tmpl { symbol : "G"  unit : 1000 * 1000 * 1000 }
				int_ki : Template int_with_unit_expr_tmpl { symbol : "ki"  unit : 1024 }
				int_mi : Template int_with_unit_expr_tmpl { symbol : "Mi"  unit : 1024 * 1024 }
				int_gi : Template int_with_unit_expr_tmpl { symbol : "Gi"  unit : 1024 * 1024 * 1024 }
				float_literal : Template expression_tmpl {
					level : 19
					pattern : parser.accumulate_float {
						field : $value
						in : parser.sequence {
							accumulate : True
							of : [
								valid_number {},
								parser.single { char : "." },
								parser.many {
									of : parser.range { from : "0" to : "9" }
								},
								parser.optional {
									of : parser.sequence {
										of : [
											parser.single { char : "eE" },
											parser.optional {
												of : parser.single { char : "-" }
											},
											valid_number {}
										]
									}
								}
							]
						}
					}
					apply_envrionment_to : [ ]
				}

				string_identifier : Template expression_tmpl {
					level : 19
					pattern : parser.sequence {
						of : [
							parser.exact { word : "$" },
							valid_identifier { field : $name }
						]
					}
					apply_envrionment_to : [ ]
				}
				string_literal : Template expression_tmpl {
					level : 19
					pattern : parser.sequence {
						of : [
							parser.exact { word : "\\\"" },
							parser.accumulate_list {
								field : $parts
								type : $string_piece
								in : parser.many {
									of : parser.other {
										type : $string_piece
										field : Null
									}
								}
							},
							parser.exact { word : "\\\"" }
						]
					}
					apply_envrionment_to : [ environment.list_of { field : $parts } ]
				}
			}
		}
	}
}
