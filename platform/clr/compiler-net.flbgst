compiler_lib : From lib:compiler-bootstrap

parser : compiler_lib.parser_tmpl {
	exact +: {
		class_gen : ""
		copy_instance : ""
		pok : parse_complete(ok : True, indent : indent & "\t")
		perr : parse_complete(ok : False, indent : indent & "\t")
		parser_gen : "\(indent)if (_parser.Match(\"\(word)\")) {\(pok)\(indent)} else {\(perr)\(indent)}"
	}
	optional +: {
		id : Id
		class_gen : of.class_gen
		copy_instance : of.copy_instance

		pok : (Lookup parse_complete In Container)(ok : True, indent : indent)
		parse_complete : Template {
			ok ?:
			value : If ok
				Then "\(indent)goto optional_exit_\(id);"
				Else "\(indent)_obj = _optional_obj_\(id);\(indent)_parser = _optional_parser_\(id);\(indent)goto optional_exit_\(id);"
		}
		parser_gen : "\(indent)var _optional_obj_\(id) = _obj.Clone();\(indent)Parser _optional_parser_\(id) = _parser.Clone();\(of.parser_gen)\(indent)optional_exit_\(id):\(pok)"
	}
	sequence +: {
		id : Id
		class_gen : For x : of Reduce acc & x.class_gen With acc : ""
		copy_instance : For x : of Reduce acc & x.copy_instance With acc : ""

		parent_parse_complete : Lookup parse_complete In Container
		pok : parent_parse_complete(ok : True, indent : indent & "\t")
		perr : parent_parse_complete(ok : False, indent : indent & "\t")
		parse_complete : Template {
			ok ?:
			value : If ok Then "" Else "\(indent)_sequence_fail_\(id) = true;\(indent)goto _sequence_end_\(id);"
		}
		parser_gen : "\(indent)bool _sequence_fail_\(id) = false;" & (For x : of Reduce acc & x.parser_gen With acc : "") & "\(indent)_sequence_end_\(id):\(indent)if (_sequence_fail_\(id)) {\(perr)\(indent)} else {\(pok)\(indent)}"
	}
	many +: {
		id : Id
		class_gen : of.class_gen & (If separator Is Null Then "" Else separator.class_gen)
		copy_instance : of.copy_instance & (If separator Is Null Then "" Else separator.copy_instance)

		parent_indent : Lookup indent In Container
		indent : parent_indent & "\t"

		parent_parse_complete : Lookup parse_complete In Container
		pok : parent_parse_complete(ok : True, indent : indent)
		perr : parent_parse_complete(ok : False, indent : indent)
		parse_complete : Template {
			ok ?:
			value: If ok Then "" Else "\(indent)_parser = _many_parser_\(id);\(indent)_obj = _many_obj_\(id);\(indent)break;"
		}
		need_first : nonempty || !(separator Is Null)
		parser_gen : (If need_first Then "\(parent_indent)bool _first_\(id) = true;" Else "") &
			"\(parent_indent)while(true) {\(indent)Parser _many_parser_\(id) = _parser.Clone();\(indent)var _many_obj_\(id) = _obj.Clone();" &
			(If separator Is Null Then "" Else "\(indent)if (!_first_\(id)) {\(separator.parser_gen)\(indent)}") &
			of.parser_gen & (If need_first Then "\(indent)_first_\(id) = false;" Else "") &
			"\(parent_indent)}" &
			(If nonempty Then "\(parent_indent)if (_first_\(id)) {\(perr)\(parent_indent)} else {\(pok)\(parent_indent)}" Else pok)
	}
	alternate +: {
		id : Id
		class_gen : For x : of Reduce acc & x.class_gen With acc : ""
		copy_instance : For x : of Reduce acc & x.copy_instance With acc : ""

		parent_indent : Lookup indent In Container
		indent : parent_indent & "\t"

		parent_parse_complete : Lookup parse_complete In Container
		pok : parent_parse_complete(ok : True, indent : indent)
		perr : parent_parse_complete(ok : False, indent : indent)
		parse_complete : Template {
			ok ?:
			value : If ok
				Then "\(indent)_alternate_success_\(id) = true;"
				Else "\(indent)_parser = _alt_parser_\(id);\(indent)_obj = _alt_obj_\(id);"
		}
		parser_gen : "\(parent_indent)bool _alternate_success_\(id) = false;\(parent_indent)Parser _alt_parser_\(id) = _parser.Clone();\(parent_indent)var _alt_obj_\(id) = _obj.Clone();" &
			(For x : of
			Reduce acc & "\(parent_indent)if (!_alternate_success_\(id)) {\(x.parser_gen)\(parent_indent)}"
			With acc : "") &
			"\(parent_indent)if (_alternate_success_\(id)) {\(pok)\(parent_indent)} else {\(perr)\(parent_indent)}"
	}
	range +: {
		class_gen : ""
		copy_instance : ""
		pok : parse_complete(ok : True, indent : indent & "\t")
		perr : parse_complete(ok : False, indent : indent & "\t")
		acc : If accumulate Then (accumulate_char { input : "_parser.PeekLast()" }).value Else ""
		parser_gen : "\(indent)if (_parser.Next() >= '\(from)' && _parser.PeekLast() <= '\(to)') {\(acc)\(pok)\(indent)} else {\(perr)\(indent)}"
	}
	single +: {
		class_gen : ""
		copy_instance : ""
		pok : parse_complete(ok : True, indent : indent & "\t")
		perr : parse_complete(ok : False, indent : indent & "\t")
		acc : If accumulate Then (accumulate_char { input : "_parser.PeekLast()" }).value Else ""
		parser_gen : "\(indent)if (\"\(char)\".IndexOf(_parser.Next()) \(If invert_match Then "==" Else "!=") -1) {\(acc)\(pok)\(indent)} else {\(perr)\(indent)}"
	}
	accumulate_integer +: {
		require_definition : If field Is Null Then False Else
			(For common_field : Name, common_type : expanded_common Where common_field == field Reduce False With acc : True)
		class_gen : If require_definition Then "\tinternal long " & field & ";\n" & in.class_gen Else ""
		copy_instance : If require_definition Then "\t\t_obj.\(field) = \(field);\n" & in.copy_instance Else ""

		accumulate_char : Template {
			input ?:
			value : "\(indent)_obj.\(field) += _obj.\(field) * \(multiplier) + (\(input) - \(offset));"
		}
		parser_gen : in.parser_gen
	}
	accumulate_unichar_integer +: {
		unicode_accumulate_char : "_unicode_acc_" & Id
		class_gen : ""
		copy_instance : ""

		parent_parse_complete : Lookup parse_complete In Container
		parent_unicode_accumulate_char : Lookup accumulate_char In Container
		parse_complete : Template {
			ok ?:
			save_char : (parent_unicode_accumulate_char { input : "System.Char.ConvertFromUtf32(" & unicode_accumulate_char & ")" }).value
			pok : parent_parse_complete(ok : True, indent : indent)
			perr : parent_parse_complete(ok : False, indent : indent)
			value : If ok Then (save_char & pok) Else perr
		}
		accumulate_char : Template {
			input ?:
			value : "\(indent)\(unicode_accumulate_char) = \(unicode_accumulate_char) * \(multiplier) + (\(input) - \(offset));"
		}
		parser_gen : "\(indent)int \(unicode_accumulate_char) = \(initial);" & in.parser_gen
	}
	accumulate_float +: {
		require_definition : If field Is Null Then False Else
			(For common_field : Name, common_type : expanded_common Where common_field == field Reduce False With acc : True)
		class_gen : If require_definition Then "\tinternal double " & field & ";\n" & in.class_gen Else ""
		copy_instance : If require_definition Then "\t\t_obj.\(field) = \(field);\n" & in.copy_instance Else ""

		float_accumulate_buffer : "_float_acc_" & Id
		accumulate_char : Template {
			input ?:
			value : indent & float_accumulate_buffer & ".Append(" & input & ");"
		}
		parent_parse_complete : Lookup parse_complete In Container
		parse_complete : Template {
			ok ?:
			value : If ok
				Then indent & "if (System.Double.TryParse(\(float_accumulate_buffer).ToString(), out _obj.\(field))) {\(pok)\(indent)} else {\(perr)\(indent)}"
				Else perr
			pok : parent_parse_complete(ok : True, indent : indent & "\t")
			perr : parent_parse_complete(ok : False, indent : indent & "\t")
		}
		parser_gen : "var \(float_accumulate_buffer) = new System.Text.StringBuilder();" & in.parser_gen
	}
	accumulate_list +: {
		require_definition : If field Is Null Then False Else
			(For common_field : Name, common_type : expanded_common Where common_field == field Reduce False With acc : True)
		class_gen : If require_definition Then "\tinternal System.Collections.Generic.List<\(type)> \(field) = new System.Collections.Generic.List<\(type)>();\n" & in.class_gen Else ""
		copy_instance : If require_definition Then "\t\t_obj.\(field).AddRange(\(field));\n" & in.copy_instance Else ""
		parser_gen : in.parser_gen
	}
	accumulate_string +: {
		require_definition : If field Is Null Then False Else
			(For common_field : Name, common_type : expanded_common Where common_field == field Reduce False With acc : True)
		class_gen : If require_definition Then "\tinternal System.Text.StringBuilder " & field & " = new System.Text.StringBuilder();\n" & in.class_gen Else ""
		copy_instance : If require_definition Then "\t\t_obj.\(field).Append(\(field).ToString());\n" & in.copy_instance Else ""

		accumulate_char : Template {
			input ?:
			value : "\(indent)_obj.\(field).Append(\(input));"
		}
		parser_gen : in.parser_gen
	}
	collect_codepoint +: {
		class_gen : ""
		copy_instance : ""
		parser_gen : (accumulate_char { input : "System.Char.ConvertFromUtf32(" & codepoint & ")" }).value & parse_complete(ok : True, indent : indent)
	}
	other +: {
		require_definition : If field Is Null Then False Else
			(For common_field : Name, common_type : expanded_common Where common_field == field Reduce False With acc : True)
		class_gen : If require_definition Then "\tinternal \(type) \(field);\n" Else ""
		copy_instance : If require_definition Then "\t\t_obj.\(field) = \(field);\n" Else ""

		pok : ((Lookup parse_complete In Container) { ok : True }).value
		perr : ((Lookup parse_complete In Container) { ok : False }).value
		target_rule : "\(type).ParseRule_\(alternate ?? "Base")"
		parse_call : If field Is Null
			Then "Parser.ParseIntoList(ref _parser, _obj.\(Lookup field In Container), \(target_rule))"
			Else "\(target_rule)(ref _parser, out _obj.\(field))"
		parser_gen : "\(indent)if (\(parse_call)) {\(pok)\(indent)} else {\(perr)\(indent)}"
	}
}

common_fields : compiler_lib.common_fields_tmpl {
	str +: {
		class_gen : "\tinternal System.Text.StringBuilder \(field_name) = new System.Text.StringBuilder();\n"
		copy_instance : "\t\t_obj.\(field_name).Append(\(field_name).ToString());\n"
	}
	int +: {
		class_gen : "\tinternal long \(field_name);\n"
		copy_instance : "\t\t_obj.\(field_name) = \(field_name);\n"
	}
	float +: {
		class_gen : "\tinternal double \(field_name);\n"
		copy_instance : "\t\t_obj.\(field_name) = \(field_name);\n"
	}
	other +: {
		class_gen : "\tinternal \(type) \(field_name);\n"
		copy_instance : "\t\t_obj.\(field_name) = \(field_name);\n"
	}
}

static_copy_instance : For field : [ "StartRow", "EndRow", "StartColumn", "EndColumn", "FileName" ]
	Reduce acc & "\t\t_obj.\(field) = \(field);\n" With acc : ""

compiler : compiler_lib.language_tmpl {
	syntax_element +: {
		indent : "\n\t\t"
		class_name : group_name & "_" & rule_name
		parser_gen : "\tpublic static bool ParseRule_\(rule_name)(ref Parser _parser, out \(group_name) _result) {\n\t\tvar _obj = new \(class_name)();\n\(pattern.parser_gen)\n\t}\n"

		class_gen : "public class \(class_name) : \(group_name) {\n\(pattern.class_gen)\tpublic \(class_name) Clone() {\n\t\tvar _obj = new \(class_name)();\n\(static_copy_instance)\(common_field_copy_instance)\(pattern.copy_instance)\t\treturn _obj;\n\t}\n}\n"

		parse_complete : Template {
			ok ?:
			value : If ok Then "\(indent)_result = (\(group_name))_obj;\(indent)return true;" Else "\(indent)_result = null;\(indent)return false;"
		}
	}
	syntax_group +: {
		common_field_class_gen : For field : expanded_common Reduce acc & field.class_gen With acc : ""
		common_field_copy_instance : For field : expanded_common Reduce acc & field.copy_instance With acc : static_copy_instance

		parser_gen : For rule : expanded_rules Reduce acc & rule.parser_gen With acc : ""

		parse_base : "\tpublic static bool ParseRule_Base(ref Parser parser, out \(group_name) result) {\n\t\tParser slave_parser;" &
		(For rule : expanded_rules, rule_name : Name
			Reduce acc & "\t\tslave_parser = parser.Clone();\n\t\tif (ParseRule_\(rule_name)(ref slave_parser, out result)) {\n\t\t\tparser = slave_parser;\n\t\t\treturn true;\n\t\t}\n"
			With acc : "")
		& "\tresult = null;\n\t\treturn false;\n\t}\n"

		parse_alternates : For alternate_rules : expanded_alts, alternate_name : Name
			Reduce
				outer_acc &
				"\tpublic static bool ParseRule_\(alternate_name)(ref Parser parser, out \(group_name) result) {\n\t\tParser slave_parser;\n" &
				(For rule_name : alternate_rules
					Reduce acc & "\t\tslave_parser = parser.Clone();\n\t\tif (ParseRule_\(rule_name)(ref slave_parser, out result)) {\n\t\t\tparser = slave_parser;\n\t\t\treturn true;\n\t\t}\n"
					With acc : "")
				& "\t\tresult = null;\n\t\treturn false;\n\t}\n"
			With outer_acc : ""

		value : For rule : expanded_rules
			Reduce acc & rule.class_gen
			With acc : "public abstract class \(group_name) : AstNode {\n" & common_field_class_gen & parse_base & parse_alternates & parser_gen & "}\n"
	}
	value : "namespace Flabbergast {\n" & (For group : expanded_groups Reduce acc & group.value With acc : "") & "}"
}
