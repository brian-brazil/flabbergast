compiler_lib : From lib:compiler

# The C# implementation of the parser. The parser definitions also create the
# class definitions. Each syntax group in the compiler becomes an abstract
# class and each syntax element derives this class. The parser generated is a
# packrat parser. The memorisation logic and state information is managed by
# code elsewhere.
#
# The parser makes heavy use of `goto` to control flow. The best strategy
# (based on a search of the literature) for error reporting in a PEG parser is
# to keep the error that occurs having consumed the most input, even if the
# parser has backed up since then. The `Update` methods record and error,
# keeping only the most extreme.
#
# In the Flabbergast compiler code, the action to be taken at the end of
# parsing is the `parse_complete` template, which takes the success state and
# indentation. Parser components can redefine `parse_complete` as needed to
# define the behaviour of their children.
parser : compiler_lib.parser_tmpl {
	# Call `ParserPosition.Match` and record a failure otherwise.
	exact +: {
		class_gen : ""
		copy_instance : ""
		parser_gen :
			"\(indent)if (_position.Match(\"\(word)\")) {" &
			parse_complete(ok : True, indent : indent & "\t") &
			"\(indent)} else {" &
			"\(indent)\t_position.Update(\"“\(word)”\", \"\(pretty_name)\");" &
			parse_complete(ok : False, indent : indent & "\t") &
			"\(indent)}"
	}
	# Duplicate the current state of the object under parse, then parse another
	# rule, redefining `parse_complete` so the error state restores the previous
	# object under parse and then call the parent's `parse_complete` always with
	# success.
	optional +: {
		id : Id
		class_gen : of.class_gen
		copy_instance : of.copy_instance

		parse_complete : Template {
			ok ?:
			value : If ok
				Then "\(indent)goto optional_exit_\(id);"
				Else
					"\(indent)_obj = _optional_obj_\(id);" &
					"\(indent)_position = _optional_position_\(id);" &
					"\(indent)goto optional_exit_\(id);"
		}
		parser_gen :
			"\(indent)var _optional_obj_\(id) = _obj.Clone();" &
			"\(indent)ParserPosition _optional_position_\(id) = _position.Clone();" &
			of.parser_gen &
			"\(indent)optional_exit_\(id):" &
			(Lookup parse_complete In Container)(ok : True, indent : indent)
	}
	# Parse a number of items by parsing each item in sequence. If an error
	# occurs, a flag is set and flow is short circuited to the end. At the end,
	# the error flag is checked and the appropriate `parse_complete` is invoked.
	sequence +: {
		id : Id
		class_gen : For x : of Reduce acc & x.class_gen With acc : ""
		copy_instance : For x : of Reduce acc & x.copy_instance With acc : ""

		parent_parse_complete : Lookup parse_complete In Container
		parse_complete : Template {
			ok ?:
			value : If ok Then "" Else "\(indent)_sequence_fail_\(id) = true;\(indent)goto _sequence_end_\(id);"
		}
		parser_gen :
			"\(indent)bool _sequence_fail_\(id) = false;" &
			(For x : of Reduce acc & x.parser_gen With acc : "") &
			"\(indent)_sequence_end_\(id):" &
			"\(indent)if (_sequence_fail_\(id)) {"&
			parent_parse_complete(ok : False, indent : indent & "\t") &
			"\(indent)} else {" &
			parent_parse_complete(ok : True, indent : indent & "\t") &
			"\(indent)}"
	}
	# Parse a list of items. Inside an endless loop, the object state is copied,
	# then, if this is not the first iteration, the separator is parsed, then the
	# main parse action. If an error occurred, the object state is restored and
	# the loop exited. There is no “success” case that exits the loop.
	many +: {
		id : Id
		class_gen : of.class_gen & (If separator Is Null Then "" Else separator.class_gen)
		copy_instance : of.copy_instance & (If separator Is Null Then "" Else separator.copy_instance)

		parent_indent : Lookup indent In Container
		indent : parent_indent & "\t"

		parent_parse_complete : Lookup parse_complete In Container
		pok : parent_parse_complete(ok : True, indent : indent)
		perr : parent_parse_complete(ok : False, indent : indent)
		parse_complete : Template {
			ok ?:
			value: If ok Then "" Else "\(indent)_position = _many_position_\(id);\(indent)_obj = _many_obj_\(id);\(indent)break;"
		}
		need_first : nonempty || !(separator Is Null)
		parser_gen :
			(If need_first Then "\(parent_indent)bool _first_\(id) = true;" Else "") &
			"\(parent_indent)while(true) {" &
			"\(indent)ParserPosition _many_position_\(id) = _position.Clone();" &
			"\(indent)var _many_obj_\(id) = _obj.Clone();" &
			(If separator Is Null Then "" Else "\(indent)if (!_first_\(id)) {\(separator.parser_gen)\(indent)}") &
			of.parser_gen &
			(If need_first Then "\(indent)_first_\(id) = false;" Else "") &
			"\(parent_indent)}" &
			(If nonempty
				Then
					"\(parent_indent)if (_first_\(id)) {" &
					perr &
					"\(parent_indent)} else {" &
					pok &
					"\(parent_indent)}"
				Else pok)
	}
	# Parse exactly one path. For each path, the current object state is
	# duplicated, the parse action performed. If successful, all other paths are
	# ignored. If it fails, the stored state is restored and the next path is
	# attempted. If all paths are exhausted, the parent's `parse_complete` is
	# called with failure.
	alternate +: {
		id : Id
		class_gen : For x : of Reduce acc & x.class_gen With acc : ""
		copy_instance : For x : of Reduce acc & x.copy_instance With acc : ""

		parent_indent : Lookup indent In Container
		indent : parent_indent & "\t"

		parent_parse_complete : Lookup parse_complete In Container
		pok : parent_parse_complete(ok : True, indent : indent)
		perr : parent_parse_complete(ok : False, indent : indent)
		parse_complete : Template {
			ok ?:
			value : If ok
				Then "\(indent)_alternate_success_\(id) = true;"
				Else "\(indent)_position = _alt_position_\(id);\(indent)_obj = _alt_obj_\(id);"
		}
		parser_gen :
			"\(parent_indent)bool _alternate_success_\(id) = false;" &
			"\(parent_indent)ParserPosition _alt_position_\(id) = _position;" &
			"\(parent_indent)var _alt_obj_\(id) = _obj;" &
			(For x : of
				Reduce acc &
					"\(parent_indent)if (!_alternate_success_\(id)) {" &
					"\(indent)_position = _alt_position_\(id).Clone();" &
					"\(indent)_obj = _alt_obj_\(id).Clone();" &
					x.parser_gen &
					"\(parent_indent)}"
				With acc : "") &
			"\(parent_indent)if (_alternate_success_\(id)) {" &
			pok &
			"\(parent_indent)} else {" &
			perr &
			"\(parent_indent)}"
	}
	# Parse characters in an certain band. This simply reads the next character
	# and checks its numerical value, then invokes `parse_complete`.
	range +: {
		class_gen : ""
		copy_instance : ""
		pok : parse_complete(ok : True, indent : indent & "\t")
		perr :
			"\(indent)\t_position.Update(\"character between “\(from)” and “\(to)”\", \"\(pretty_name)\");" &
			parse_complete(ok : False, indent : indent & "\t")
		acc : If accumulate
			Then (accumulate_char { input : "_position.PeekLast()" }).value
			Else ""
		parser_gen :
			"\(indent)if (_position.Next() >= '\(from)' && _position.PeekLast() <= '\(to)') {" &
			acc & pok &
			"\(indent)} else {" &
			perr &
			"\(indent)}"
	}
	# Simply read a character from the parse stream.
	single +: {
		class_gen : ""
		copy_instance : ""
		acc : If accumulate
			Then (accumulate_char { input : "_position.PeekLast()"  indent : Lookup indent In Container & "\t"}).value
			Else ""
		parser_gen : "\(indent)if (\"\(char)\".IndexOf(_position.Next()) \(If invert_match Then "==" Else "!=") -1) {" &
			acc & parse_complete(ok : True, indent : indent & "\t") &
			"\(indent)} else {" &
			"\(indent)\t_position.Update(Parser.ToLiteral(\"\(char)\"), \"\(pretty_name)\");" &
			parse_complete(ok : False, indent : indent & "\t") &
			"\(indent)}"
	}
	# Parse a character and check its Unicode class. All the real work is done by
	# the system libraries.
	char_class +: {
		class_gen : ""
		copy_instance : ""

		acc : If accumulate
			Then (accumulate_char { input : "_position.PeekLast()"  indent : Lookup indent In Container & "\t"}).value
			Else ""

		match_expr :
			For class : classes
			Reduce
				"\(acc) || char_class_\(Id) == System.Globalization.UnicodeCategory.\(class.enum)"
			With acc : "false"

		accepted_names :
			For class : classes
			Reduce
				If acc Is Null
					Then class.name
					Else (acc & " or " & class.name)
			With acc : Null

		parser_gen :
			"\(indent)var char_class_\(Id) = System.Char.GetUnicodeCategory(_position.Next());" &
			"\(indent)if (" &
			(If invert_match Then "!(\(match_expr))" Else match_expr) &
			") {" &
			acc & parse_complete(ok : True, indent : indent & "\t") &
			"\(indent)} else {" &
			"\(indent)\t_position.Update(\"character \(If invert_match Then "not " Else "")of type \(accepted_names ?? "unknown")\", \"\(pretty_name)\");" &
			parse_complete(ok : False, indent : indent & "\t") &
			"\(indent)}"

		letter_lower : { name : "lower-case letter"  enum : "LowercaseLetter" }
		letter_modifier : { name : "modifier letter"  enum : "ModifierLetter" }
		letter_other : { name : "other letter"  enum : "OtherLetter" }
		letter_title : { name : "title-case letter"  enum : "TitlecaseLetter" }
		letter_upper : { name : "upper-case letter"  enum : "UppercaseLetter" }
		mark_combining : { name : "spacing combining mark"  enum : "SpacingCombiningMark" }
		mark_enclosing : { name : "enclosing mark"  enum : "EnclosingMark" }
		mark_nonspace : { name : "non-spaching modification mark"  enum : "NonSpacingMark" }
		number_decimal : { name : "decimal numeral"  enum : "DecimalDigitNumber" }
		number_letter : { name : "letter-like numeral"  enum : "LetterNumber" }
		number_other : { name : "other number"  enum : "iOtherNumber" }
		other_control : { name : "control code"  enum : "Control" }
		other_format : { name : "format layout"  enum : "Format" }
		other_private : { name : "private use"  enum : "PrivateUse" }
		other_surrogate : { name : "surrogate"  enum : "Surrogate" }
		other_unassigned : { name : "unassigned"  enum : "OtherNotAssigned" }
		punctuation_connector : { name : "connecting punctuation"  enum : "ConnectorPunctuation" }
		punctuation_dash : { name : "dash"  enum : "DashPunctuation" }
		punctuation_final_quote : { name : "closing qutation mark"  enum : "FinalQuotePunctuation" }
		punctuation_initial_quote : { name : "opening quotation mark"  enum : "InitialQuotePunctuation" }
		punctuation_other : { name : "miscellaneous punctuation"  enum : "OtherPunctuation" }
		punctuation_start : { name : "starting punctuation"  enum : "OpenPunctuation" }
		separator_line : { name : "line separator"  enum : "LineSeparator" }
		separator_paragraph : { name : "paragraph separator"  enum : "ParagraphSeparator" }
		separator_space : { name : "space"  enum : "SpaceSeparator" }
		symbol_currency : { name : "currency"  enum : "CurrencySymbol" }
		symbol_math : { name : "mathematical operator"  enum : "MathSymbol" }
		symbol_modifier : { name : "modifier symbol"  enum : "ModifierSymbol" }
		symbol_other : { name : "miscellanous symbol"  enum : "OtherSymbol" }
	}
	# Peek a head in the buffer and make sure the buffer is either empty or the
	# next character doesn't occur in the specified set of characters.
	except +: {
		class_gen : ""
		copy_instance : ""
		parser_gen : "\(indent)if (_position.Index >= _position.Parser.Input.Length || \"\(char)\".IndexOf(_position.Parser.Input[_position.Index]) == -1) {" &
			parse_complete(ok : True, indent : indent & "\t") &
			"\(indent)} else {" &
			"\(indent)\t_position.Update(\"anything except \" + Parser.ToLiteral(\"\(char)\"), \"\(pretty_name)\");" &
			parse_complete(ok : False, indent : indent & "\t") &
			"\(indent)}"
	}
	# Define a field for a long integer and, for each character accumulated, do a
	# multiply-and-accumulate operation on the field.
	accumulate_integer +: {
		require_definition :
				For common_field : Name, common_type : expanded_common
				Where common_field == field
				Reduce False
				With acc : True
		class_gen : If require_definition Then "\tinternal long " & field & ";\n" & in.class_gen Else ""
		copy_instance : If require_definition Then "\t\t_obj.\(field) = \(field);\n" & in.copy_instance Else ""

		accumulate_char : Template {
			input ?:
			value : "\(indent)_obj.\(field) += _obj.\(field) * \(multiplier) + (\(input) - \(offset));"
		}
		parser_gen : in.parser_gen
	}
	# This is similar to `accumulate_integer`, but the accumulation is done in a
	# local variable and then converted to a Unicode character in a field.
	#
	# Because this uses a local buffer, it is fragile when combined with
	# `optional` or `alternate`, since they can turn failure into success,
	# allowing a buffer that should be discarded to be saved.
	accumulate_unichar_integer +: {
		unicode_accumulate_char : "_unicode_acc_" & Id
		class_gen : ""
		copy_instance : ""

		parent_parse_complete : Lookup parse_complete In Container
		parent_unicode_accumulate_char : Lookup accumulate_char In Container
		parse_complete : Template {
			ok ?:
			save_char : (parent_unicode_accumulate_char { input : "System.Char.ConvertFromUtf32(" & unicode_accumulate_char & ")" }).value
			pok : parent_parse_complete(ok : True, indent : indent)
			perr : parent_parse_complete(ok : False, indent : indent)
			value : If ok Then (save_char & pok) Else perr
		}
		accumulate_char : Template {
			input ?:
			value : "\(indent)\(unicode_accumulate_char) = \(unicode_accumulate_char) * \(multiplier) + (\(input) - \(offset));"
		}
		parser_gen : "\(indent)int \(unicode_accumulate_char) = \(initial);" & in.parser_gen
	}
	# Accumulates a float. Doing character-at-a-time float conversion is
	# impractical when compared to integers. It there for accumulates into a text
	# buffer, then uses the system's float parser to do the work.
	#
	# Because this uses a local buffer, it is fragile when combined with
	# `optional` or `alternate`, since they can turn failure into success,
	# allowing a buffer that should be discarded to be saved.
	accumulate_float +: {
		require_definition :
			For common_field : Name, common_type : expanded_common
			Where common_field == field
			Reduce False
			With acc : True
		class_gen : If require_definition Then "\tinternal double " & field & ";\n" & in.class_gen Else ""
		copy_instance : If require_definition Then "\t\t_obj.\(field) = \(field);\n" & in.copy_instance Else ""

		float_accumulate_buffer : "_float_acc_" & Id
		accumulate_char : Template {
			input ?:
			value : indent & float_accumulate_buffer & ".Append(" & input & ");"
		}
		parent_parse_complete : Lookup parse_complete In Container
		parse_complete : Template {
			ok ?:
			value : If ok
				Then
					"\(indent)if (System.Double.TryParse(\(float_accumulate_buffer).ToString(), out _obj.\(field))) {" &
					pok &
					"\(indent)} else {" &
					perr &
					"\(indent)}"
				Else perr
			pok : parent_parse_complete(ok : True, indent : indent & "\t")
			perr : parent_parse_complete(ok : False, indent : indent & "\t")
		}
		parser_gen : "var \(float_accumulate_buffer) = new System.Text.StringBuilder();" & in.parser_gen
	}
	# Accumulates items into a list. There is a second buffer to prevent
	# duplication, prepopulated with forbidden values.
	accumulate_list +: {
		require_definition : If field Is Null Then False Else
			(For common_field : Name, common_type : expanded_common Where common_field == field Reduce False With acc : True)
		forbidden_pairs : For f : forbid Reduce acc & "{ " & (If f Is Str Then "\"\(f)\"" Else f) & ", true}," With acc : ""
		class_gen :
			(If require_definition
				Then
					"\tinternal System.Collections.Generic.List<\(type)> \(field) = new System.Collections.Generic.List<\(type)>();\n" &
					(If deduplicate Is Null
						Then ""
						Else "\tinternal System.Collections.Generic.Dictionary<\(deduplicate.dedup_type), bool> \(field)_dedup = new System.Collections.Generic.Dictionary<\(deduplicate.dedup_type), bool>{\(forbidden_pairs)};\n")
				Else "") & in.class_gen
		copy_instance :
			(If require_definition
				Then
					"\t\t_obj.\(field).AddRange(\(field));\n" &
					(If deduplicate Is Null Then "" Else "\t\tforeach(var _element in \(field)_dedup.Keys) _obj.\(field)_dedup[_element] = true;\n")
				Else "")
				& in.copy_instance
		parser_gen : in.parser_gen
	}
	# Accumulates characters into a string builder.
	accumulate_string +: {
		require_definition : If field Is Null Then False Else
			(For common_field : Name, common_type : expanded_common Where common_field == field Reduce False With acc : True)
		class_gen : If require_definition Then "\tinternal System.Text.StringBuilder " & field & " = new System.Text.StringBuilder();\n" & in.class_gen Else ""
		copy_instance : If require_definition
			Then "\t\t_obj.\(field).Append(\(field).ToString());\n" & in.copy_instance
			Else ""

		accumulate_char : Template {
			input ?:
			value : "\(indent)_obj.\(field).Append(\(input));"
		}
		parser_gen : in.parser_gen
	}
	# Accumulates a character from a numeric literal.
	collect_codepoint +: {
		class_gen : in.class_gen
		copy_instance : in.copy_instance

		parent_parse_complete : Lookup parse_complete In Container
		parse_complete : Template {
			ok ?:
			value : If ok
				Then
					(accumulate_char { input : "System.Char.ConvertFromUtf32(" & codepoint & ")" }).value &
					parent_parse_complete(ok : True, indent : indent)
				Else parent_parse_complete(ok : False, indent : indent)
		}
		parser_gen : in.parser_gen
	}
	# Calls another parse rule, passing a reference to our current state to the
	# other rule. The rule may change either the parse state object or instance
	# to which the reference refers.
	#
	# There's a mess to handle parsing into lists versus fields and to handle
	# de-duplication in lists.
	other +: {
		require_definition : If field Is Null Then False Else
			(For common_field : Name, common_type : expanded_common Where common_field == field Reduce False With acc : True)
		class_gen : If require_definition Then "\tinternal \(type) \(field);\n" Else ""
		copy_instance : If require_definition Then "\t\t_obj.\(field) = \(field);\n" Else ""

		pok : ((Lookup parse_complete In Container) { ok : True }).value
		perr : ((Lookup parse_complete In Container) { ok : False }).value
		target_rule :
			Let base : "\(type).ParseRule_\(alternate ?? "Base")"
			In
				If field Is Null && !(deduplicate Is Null)
				Then
					Let dedup_container : "_obj." & Lookup field In Container & "_dedup"
					In "(ref ParserPosition _iposition, out \(type) _iresult) => { if (\(base)(ref _iposition, out _iresult)) { if (\(dedup_container).ContainsKey(_iresult.\(deduplicate.dedup_key))) { _iposition.NameConstraint(_iresult.\(deduplicate.dedup_key)); return false; } else { \(dedup_container)[_iresult.\(deduplicate.dedup_key)] = true; return true; } } else { return false; } }"
				Else base
		parse_call : If field Is Null
			Then "ParserPosition.ParseIntoList(ref _position, _obj.\(Lookup field In Container), \(target_rule))"
			Else "\(target_rule)(ref _position, out _obj.\(field))"
		parser_gen : "\(indent)if (\(parse_call)) {\(pok)\(indent)} else {\(perr)\(indent)}"
	}
}
# Some times, different parse rules should share fields across classes. These
# define the rules.
common_fields : compiler_lib.common_fields_tmpl {
	str +: {
		class_gen : "\tinternal System.Text.StringBuilder \(field_name) = new System.Text.StringBuilder();\n"
		copy_instance : "\t\t_obj.\(field_name).Append(\(field_name).ToString());\n"
		dedup_type : "string"
		dedup_key : "\(field_name).ToString()"
	}
	int +: {
		class_gen : "\tinternal long \(field_name);\n"
		copy_instance : "\t\t_obj.\(field_name) = \(field_name);\n"
		dedup_type : "int"
		dedup_key : field_name
	}
	float +: {
		class_gen : "\tinternal double \(field_name);\n"
		copy_instance : "\t\t_obj.\(field_name) = \(field_name);\n"
		dedup_type : "float"
		dedup_key : field_name
	}
	other +: {
		class_gen : "\tinternal \(type) \(field_name);\n"
		copy_instance : "\t\t_obj.\(field_name) = \(field_name);\n"
		dedup_type : type
		dedup_key : field_name
	}
}

# When making copies of a syntax node, the code to copy all support fields not
# defined in the compiler proper.
static_copy_instance : For field : [ "StartRow", "EndRow", "StartColumn", "EndColumn", "FileName" ]
	Reduce acc & "\t\t_obj.\(field) = \(field);\n" With acc : ""

# Definitions for environment-handling code. Most of the environment code is
# defined in the `Environment` and `NameInfo` classes.
environment : compiler_lib.environment_tmpl {
	other_elements +: {
		class_gen : ""
		value : For field : fields
			Reduce acc & "\t\tif (\(field) != null) { \(field).Propagate\(target_flavour.name)Environment(_collector, _queue, \(current_environment)); }\n"
			With acc : ""
	}
	list_of +: {
		class_gen : ""
		value : "\t\tif (\(field) != null) { foreach (var \(Id) in \(field)) \(Id).Propagate\(target_flavour.name)Environment(_collector, _queue, \(current_environment)); }\n"
	}
	list_independent +: {
		class_gen : ""
		value : "\t\tif (\(field) != null) { foreach (var \(Id) in \(field)) \(Id).Propagate\(target_flavour.name)Environment(_collector, _queue, new Environment(\(Id).FileName, \(Id).StartRow, \(Id).StartColumn, \(Id).EndRow, \(Id).EndColumn, \(If inherit Then current_environment Else "null"), false)); }\n"
	}
	blank_environment +: {
		current_environment : name ?? Id
		class_gen :
			For application : apply_to
				Reduce acc & application.class_gen
				With acc : If name Is Null Then "" Else "\t\tEnvironment \(name);\n"

		value :
			"\t\tvar \(name ?? Id) = new Environment(FileName, StartRow, StartColumn, EndRow, EndColumn, null, false);" &
			(For application : apply_to Reduce acc & application.value With acc : "")
	}
	modified_environment +: {
		current_environment : name ?? Id
		class_gen :
			For application : apply_to
				Reduce acc & application.class_gen
				With acc : If name Is Null Then "" Else "\t\tEnvironment \(name);\n"
		value :
			"\t\tvar \(name ?? Id) = new Environment(FileName, StartRow, StartColumn, EndRow, EndColumn, \(Lookup current_environment In Container), \(If force_back Then "true" Else "false"));\n" &
			(For special_name : special_names Reduce acc & special_name.value With acc : "") &
			(For application : apply_to Reduce acc & application.value With acc : "")

		masks_from_definitions +: {
			value : "\t\tif (\(field) != null) foreach (var \(Id) in \(field)) {\n" &
				"\t\t\t\(Id).AddMask(_collector, \(current_environment));\n" &
				"\t\t}\n"
		}
		mask_from_fields +: {
			value : "\t\t\tif(\(name_field).Length > 0) { \(current_environment).AddMask(\(name_field).ToString(), \(expr_field)); }\n"
		}
		free_name_from_field +: {
			value : "\t\t\tif(\(field).Length > 0) { \(current_environment).AddFreeName(\(field).ToString()); }\n"
		}
		forbidden_name_from_field : Template {
			value : "\t\t\tif(\(field).Length > 0) { \(current_environment).AddForbiddenName(\(field).ToString()); }\n"
		}
	}
	complex_flavour_tmpl : Template flavour_tmpl {
		enabled : True
		known_flavours ?:
		method_gen : Template {
			value : propagate_code & class_gen

			class_gen :
				For application : apply_environment_to
					Reduce acc & application.class_gen
					With acc : ""

			propagate_code :
				For current_flavour : known_flavours
				Reduce
					method_acc &
					"\tinternal override void Propagate\(current_flavour.name)Environment(ErrorCollector _collector, System.Collections.Generic.List<AstTypeableNode> _queue, Environment _environment) {\n" &
					"\t\t\(current_flavour.target_field) = _environment;\n" &
					(If current_flavour.queued Then "\t\t_queue.Add(this);\n" Else "") &
					(For application : apply_environment_to
						Where application.flavour.id == current_flavour.id
						Reduce acc & application.value
						With acc : "")
					& "\t}\n"
				With method_acc : ""
		}
	}
	flavour_none : flavour_tmpl {
		id : Null
		enabled : False
		class_name : "AstNode"
		method_gen : Template { value : "" }
	}
	flavour_simple : complex_flavour_tmpl {
		id : 0
		class_name : "AstTypeableNode"
		name : ""
		queued : True
		target_field : "Environment"
		known_flavours : [ This ]
	}
	flavour_double : complex_flavour_tmpl {
		class_name : "AstTypeableSpecialNode"
		id : 1
		name : "Special"
		queued : False
		target_field : "SpecialEnvironment"
		known_flavours : [ flavour_simple, This ]
	}
}
# The correspondence between Flabbergast types in the compiler and their
# implementation types (a.k.a. `real_type`) and the flag used in the union
# types used by the environments to propagate type information (a.k.a.
# `union_type`).
known_types : compiler_lib.known_types_tmpl {
	bool : {
		union_type : "Flabbergast.Type.Bool"
		real_type : "bool"
		max : "true"
		min : "false"
		constant_creator : "BoolConstant"
	}
	float : {
		union_type : "Flabbergast.Type.Int"
		real_type : "double"
		max : "System.Double.MaxValue"
		min : "System.Double.MinValue"
		constant_creator : "FloatConstant"
	}
	frame : {
		union_type : "Flabbergast.Type.Frame"
		real_type : "Flabbergast.Frame"
	}
	int : {
		union_type : "Flabbergast.Type.Float"
		real_type : "long"
		max : "System.Int64.MaxValue"
		min : "System.Int64.MinValue"
		constant_creator : "IntConstant"
	}
	str : {
		union_type : "Flabbergast.Type.Str"
		real_type : "Flabbergast.Stringish"
	}
	template : {
		union_type : "Flabbergast.Type.Template"
		real_type : "Flabbergast.Template"
	}
	unit : {
		union_type : "Flabbergast.Type.Unit"
		real_type : "Flabbergast.Unit"
	}
}
# These are types known by the KWS VM that are not found in the Flabbergast
# language. Therefore, they have a `real_type`, but not a `union_type`.
known_vm_types : compiler_lib.known_vm_types_tmpl {
	any : { real_type : "object" }
	list : { real_type : "Flabbergast.Context" }
}
# The mechanism code to do type checking in the compiler. Each syntax element
# is told what types it may return and it propagates this type information to
# its children. If the union is ever empty, a type error occurs, since this
# implies that there is no possible type that could satisfy this expression.
ensure_type : compiler_lib.ensure_type_tmpl {
	# Restrict the union and check if the intersection is empty.
	filter +: {
		type_bits : For t : types Reduce acc & " | " & t.union_type With acc : "0"

		parent_indent : Lookup indent In Container
		indent : parent_indent & "\t"

		parent_type : Lookup current_type In Container
		current_type : Id

		value : "\(parent_indent)var \(Id) = \(parent_type) & (\(type_bits));" &
			"\(parent_indent)if (\(Id) == 0) {" &
			"\(indent)collector.ReportTypeError(this, \(type_bits), \(parent_type));" &
			"\(parent_indent)} else {" &
			ensure_type_of.value &
			"\(parent_indent)}"
	}
	# Pass this type to a child node.
	propagate +: {
		allowed_type_bits : For t : extra_types Reduce acc & " | " & t.union_type With acc : current_type
		value : For field : fields Reduce acc & "\(indent)if (\(field) != null) \(field).EnsureType(collector, \(allowed_type_bits));" With acc : ""
	}
	# Pass this type to all child nodes in a list.
	propagate_all +: {
		allowed_type_bits : For t : extra_types Reduce acc & " | " & t.union_type With acc : current_type
		value : "\(indent)if (\(field) != null) foreach (var \(Id) in \(field)) \(Id).EnsureType(collector, \(allowed_type_bits));"
	}
	# This works similarly to filter, but takes the type from a syntax node
	# rather than a literal in the compiler.
	dynamic +: {
		parent_indent : Lookup indent In Container
		indent : parent_indent & "\t"

		parent_type : Lookup current_type In Container
		current_type : Id

		type_bits : "\(field).\(If propagate_castable Then "CastableFrom" Else "TypeId")"
		value : "\(parent_indent)var \(Id) = \(parent_type) & \(type_bits);" &
			"\(parent_indent)if (\(Id) == 0) {" &
			"\(indent)collector.ReportTypeError(this, \(type_bits), \(parent_type));" &
			"\(parent_indent)} else {" &
			ensure_type_of.value &
			"\(parent_indent)}"
	}
	# Stores the type information in the environment by lookup name.
	stored +: {
		value : "\(indent)Environment.Lookup(collector, \(field).Select((s) => s.ToString())).EnsureType(collector, \(current_type));"
	}
	# Stores the type information in the environment by syntax node.
	intrinsic +: {
		value : "\(indent)Environment.EnsureIntrinsic(collector, this, \(current_type));"
	}
	stop +: { value : "" }
	multiple +: {
		value : For action : actions Reduce acc & action.value With acc : ""
	}
}
default_indent : "\n\t\t"
# Code to generate CIL opcodes, using System.Reflection.Emit for KWS VM
# instructions. This is heavily supported by the `Generator` class. This code
# also makes obscene use of callbacks. Per the compiler design manual, the
# continuation passing flow of the language is represented in the compiler. At
# most steps, a callback is created which takes the return value as an
# argument.
#
# The compiler makes heavy use of “private scope” fields, which are essentially
# anonymous fields. Each instruction stores its results in a field defined by
# `storage_name`.
kws : compiler_lib.kws_tmpl {
	# The base template for most instructions. Since each instruction computes
	# some values and then does one opcode, this is heavily applicable to most of
	# the “normal” operations in the KWS VM. This template takes the arguments,
	# expands their `gen_gen` templates in a fold operation, finally loading all
	# the results, inserting the opcodes, then storing the result in a field.
	base_tmpl +: {
		opcode ?:
		storage_name : If return_type Is Null Then "null" Else Id

		extra_indent : For arg : arguments Reduce arg.value.extra_indent & acc With acc : ""
		arg_indents : For arg_name : Name, arg : arguments, arg_pos : Ordinal
			Select arg_name :
				(For prev_arg : arguments, prev_arg_pos : Ordinal
				Where prev_arg_pos < arg_pos
				Reduce acc & prev_arg.value.extra_indent
				With acc : "")

		gen_gen +: {
			sum_indent : indent & extra_indent

			extra_load : "\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);"
			extra_emit : ""
			store_result :
				"\(sum_indent)var \(storage_name) = \(generator).MakeField(\"\(rule_name)_\(opcode)\", typeof(\(return_type.real_type)));" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Stfld, \(storage_name).Field);" &
				code

			base_code :
				For arg : arguments
					Reverse
					Reduce
						"\(sum_indent)if (\(arg.value.storage_name).BackingType != typeof(\(arg.type.real_type))) throw new System.InvalidOperationException();" &
						"\(sum_indent)\(arg.value.storage_name).Load(\(generator));" &
						acc
						With acc :
							"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.\(opcode)\(extra_emit));" & store_result

			value :
				For arg : arguments, arg_indent : arg_indents
				Reverse
				Reduce arg.value.gen_gen(code : acc, indent : indent & arg_indent)
				With acc : extra_load & base_code
		}
	}
	bool_negate +: {
		opcode : "Ldc_I4_0"
		gen_gen +: {
			store_result +original:
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ceq);" &
				original
		}
	}
	error +: {
		opcode : "Callvirt"
		gen_gen +: {
			extra_load : "\(sum_indent)\(generator).LoadTaskMaster();\(sum_indent)\(parameters.source_reference.storage_name).Load(\(generator));"
			extra_emit : ", typeof(TaskMaster).GetMethod(\"ReportOtherError\")"
			store_result : "\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_0);\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ret);"
		}
	}
	float_add +: { opcode : "Add" }
	float_divide +: { opcode : "Div" }
	float_is_finite +: {
		opcode : "Call"
		gen_gen +: {
			extra_emit : ", typeof(double).GetMethod(\"IsInfinity\")"
			store_result +original:
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_0);" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ceq);" &
				original
		}
	}
	float_is_nan +: {
		opcode : "Call"
		gen_gen +: {
			extra_emit : ", typeof(double).GetMethod(\"IsNaN\")"
		}
	}
	float_modulus +: { opcode : "Rem" }
	float_multiply +: { opcode : "Mul" }
	float_negate +: { opcode : "Neg" }
	float_subtract +: { opcode : "Sub" }
	float_to_int +: { opcode : "Conv_I8" }
	int_add +: { opcode : "Add" }
	int_divide +: { opcode : "Div" }
	int_modulus +: { opcode : "Rem" }
	int_multiply +: { opcode : "Mul" }
	int_negate +: { opcode : "Neg" }
	int_subtract +: { opcode : "Sub" }
	int_to_bool +: {
		opcode : "Conv_I4"
		gen_gen +: {
			store_result +original:
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, \(number));" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ceq);" &
				(If invert
					Then
						"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_0);" &
						"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ceq);"
					Else "") &
				original
		}
	}
	int_to_float +: { opcode : "Conv_R4" }
	string_concatenate +: {
		opcode : "Newobj"
		gen_gen +: {
			extra_emit : ", typeof(ConcatStringish).GetConstructors()[0]"
		}
	}
	string_ordinal +: {
		opcode : "Call"
		gen_gen +: {
			extra_emit : ", typeof(TaskMaster).GetMethod(\"OrdinalName\")"
		}
	}
	frame_new +: {
		opcode : "Newobj"
		extra_load +original: original &
			"\(sum_indent)\(generator).GenerateNextId();" &
			"\(sum_indent)\(parameters.source_reference.storage_name).Load(\(generator));"
		gen_gen +: {
			extra_emit : ", typeof(Frame).GetConstructors()[0]"
		}
	}
	frame_new_through +: {
		opcode : "Call"
		gen_gen +: {
			extra_load +original: original &
				"\(sum_indent)\(generator).GenerateNextId();" &
				"\(sum_indent)\(parameters.source_reference.storage_name).Load(\(generator));"
			extra_emit : ", typeof(Frame).GetMethod(\"Through\")"
		}
	}
	frame_id +: {
		opcode : "Call"
		gen_gen +: {
			extra_emit : ", typeof(Frame).GetMethod(\"get_Id\")"
		}
	}
	frame_context +: {
		opcode : "Call"
		gen_gen +: {
			extra_emit : ", typeof(Frame).GetMethod(\"get_Context\")"
		}
	}
	list_null +: {
		extra_indent : ""
		storage_name : "LoadableValue.NULL_LIST"
	}
	list_prepend +: {
		opcode : "Call"
		gen_gen +: {
			extra_emit : ", typeof(Context).GetMethod(\"Prepend\")"
		}
	}
	list_append +: {
		opcode : "Call"
		gen_gen +: {
			extra_emit : ", typeof(Context).GetMethod(\"Append\")"
		}
	}
	lookup_tmpl +: {
		opcode : "Newobj"
		gen_gen +: {
			extra_load :
				"\(sum_indent)\(generator).LoadTaskMaster();" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Dup);" &
				"\(sum_indent)\(parameters.source_reference.storage_name).Load(\(generator));"
			extra_emit : ", typeof(Lookup).GetConstructors()[0]"
			store_result :
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Dup);" &
				"\(sum_indent)var \(storage_name) = \(generator).MakeField(\"lookup\",typeof(object));" &
				"\(sum_indent)\(generator).GenerateConsumeResult(\(storage_name));" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Call, typeof(Lookup).GetMethod(\"Notify\"));" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Call, typeof(TaskMaster).GetMethod(\"Slot\"));" &
				"\(sum_indent)var \(Id)_state = \(generator).DefineState();" &
				"\(sum_indent)\(generator).SetState(\(Id)_state);" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_0);" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ret);" &
				"\(sum_indent)\(generator).MarkState(\(Id)_state);" &
				code
		}
	}
	lookup_literal +: {
		gen_gen +: {
			names_length : For n : name Reduce acc + 1 With acc : 0
			load_names :
				For n : name, index : Ordinal
					Reduce
						acc &
						"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Dup);" &
						"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, \(index - 1));" &
						"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldstr, \"\(n)\");" &
						"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Stelem);"
					With acc :
						"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, \(names_length));" &
						"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Newarr, typeof(string));"
		}
	}
	lookup_field +: {
		gen_gen +: {
			load_names :
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, \(field).Count);" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Newarr, typeof(string));" &
				"\(sum_indent)for (var \(Id)_iter = 0; \(Id)_iter < \(field).Count; \(Id)_iter++) {" &
				"\(sum_indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Dup);" &
				"\(sum_indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, \(Id)_iter);" &
				"\(sum_indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldstr, \(field)[\(Id)_iter].ToString());" &
				"\(sum_indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Stelem);" &
				"\(sum_indent)}"
		}
	}

	cast_to_string +: {
		extra_indent : source.extra_indent
		gen_gen +: {
			value : source.gen_gen(
				indent : indent,
				code :
					"\(indent)var \(storage_name) = \(generator).MakeField(\"str\", typeof(Stringish));" &
					"\(indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);" &
					"\(indent)\(generator).ToStringish(\(source.storage_name), \(parameters.source_reference.storage_name));" &
					"\(indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Stfld, \(storage_name).Field);" &
					code
				)
		}
	}
	string_constant_tmpl +: {
		extra_indent : ""
		source ?:
		gen_gen +: {
			value : "\(indent)var \(storage_name) = new StringishValue(\(source));" & code
		}
	}
	string_constant +: {
		source : "\"" & str & "\""
	}
	string_constant_from_field +: {
		source : field & ".ToString()"
	}
	string_length +: {
		opcode : "Call"
		extra_emit : ", typeof(Stringish).GetMethod(\"get_Length\")"
	}
	numeric_constant +: {
		extra_indent : ""
		max : type.max
		min : type.min
		gen_gen +: {
			value : "\(indent)var \(storage_name) = new \(type.constant_creator)(\(number));" & code
		}
	}
	numeric_constant_units +: {
		number : "\(field) * \(unit)"
	}
	null_constant +: {
		extra_indent : ""
		gen_gen +: {
			value : "\(indent)var \(storage_name) = UnitConstant.NULL;" & code
		}
	}
	nan_constant +: {
		extra_indent : ""
		gen_gen +: {
			value : "\(indent)var \(storage_name) = FloatConstant.NAN;" & code
		}
	}
	infinity_constant +: {
		extra_indent : ""
		gen_gen +: {
			value : "\(indent)var \(storage_name) = FloatConstant.INFINITY;" & code
		}
	}
	compare +: {
		extra_indent : left.extra_indent & right.extra_indent & "\t"
		gen_gen +: {
			sum_indent : indent & extra_indent
			base_code :
				"\(sum_indent)if (\(left.storage_name).BackingType == typeof(object) || \(right.storage_name).BackingType == typeof(object)) {" &
				"\(sum_indent)\tthrow new System.InvalidOperationException();" &
				"\(sum_indent)} else if (\(left.storage_name).BackingType != \(right.storage_name).BackingType) {" &
				"\(sum_indent)\t\(generator).EmitTypeError(\(parameters.source_reference.storage_name), \"Cannot compare value of type {0} and type {1}.\", \(left.storage_name), \(right.storage_name));" &
				"\(sum_indent)} else {" &
				"\(sum_indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);" &
				"\(sum_indent)\t\(left.storage_name).Load(\(generator));" &
				"\(sum_indent)\t\(right.storage_name).Load(\(generator));" &
				"\(sum_indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Call, \(left.storage_name).BackingType.GetMethod(\"CompareTo\"));" &
				"\(sum_indent)\t\(generator).Clamp();" &
				"\(sum_indent)\tvar \(storage_name) = \(generator).MakeField(\"compare\", typeof(long));" &
				"\(sum_indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Stfld, \(storage_name).Field);" &
				code &
				"\(sum_indent)}"

			value : left.gen_gen(
				indent : indent,
				code : right.gen_gen(
					indent : indent & left.extra_indent,
					code : base_code
					)
				)
		}
	}
	conditional +: {
		extra_indent : condition.extra_indent & "\t"
		callback : Id & "_code"

		gen_gen +: {
			sum_indent : indent & condition.extra_indent
			value : condition.gen_gen(
				indent : indent,
				code :
					"\(sum_indent)Generator.ParameterisedBlock<LoadableValue> \(callback) = (\(storage_name)) => {\(code)\(sum_indent)};" &
					"\(sum_indent)if (!typeof(bool).IsAssignableFrom(\(condition.storage_name).BackingType)) throw new System.InvalidOperationException();" &
					"\(sum_indent)\(condition.storage_name).Load(\(generator));" &
					"\(sum_indent)var \(Id)_else = \(generator).Builder.DefineLabel(); " &
					"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Brtrue, \(Id)_else);" &
					true_action.gen_gen(indent : sum_indent, code : "\(sum_indent)\(true_action.extra_indent)\(callback)(\(true_action.storage_name));") &
					"\(sum_indent)\(generator).Builder.MarkLabel(\(Id)_else); " &
					false_action.gen_gen(indent : sum_indent, code : "\(sum_indent)\(false_action.extra_indent)\(callback)(\(false_action.storage_name));")
				)
		}
	}
	dynamic_type_dispatch +: {
		extra_indent : of.extra_indent & "\t"
		type_list :
			For type : allow_types
			Reduce type.real_type & ", " & acc
			With acc : ""

		gen_gen +: {
			sum_indent : indent & extra_indent
			value :
				of.gen_gen(indent : indent, code :
					"\(sum_indent)_generator.DynamicTypeDispatch(\(of.storage_name), \(parameters.source_reference.storage_name), new System.Type[] { \(type_list) }, (\(storage_name)) {" &
					code &
					"\(sum_indent)});")
		}
	}
	iterator +: {
		extra_indent : For input : inputs Reduce input.extra_indent & acc With acc : initial.extra_indent
		input_indents : For input_name : Name, input : inputs, input_pos : Ordinal
			Select input_name :
				(For prev_input : inputs, prev_input_pos : Ordinal
				Where prev_input_pos < input_pos
				Reduce acc & input_arg.extra_indent
				With acc : "")
		num_inputs : For input : inputs Reduce len + 1 With len : 0

		iterator_instance : Id & "_iterator"
		iterator_state : Id & "_state"
		iterator_key : Id & "_key"
		iterator_ordinal : Id & "_ordinal"

		gen_gen +: {
			sum_indent : indent & extra_indent

			# This is the simplest part of the hideously complex: it expands all the
			# `gen_gen` templates of the input, then calls the behemoth in
			# `base_code`.
			value : initial.gen_gen(
				indent : indent,
				code :
					For input : inputs, input_indent : input_indents
					Reduce input.gen_gen(code : acc, indent : indent & input_indent)
					With acc : base_code)

			base_code :
				# Create new fields for all the bits of stuff we need.
				"\(sum_indent)var \(storage_name) = \(generator).MakeField(\"\(rule_name)_iterator_accumulator\", \(initial.storage_name).BackingType);" &
				"\(sum_indent)var \(storage_name) = \(generator).MakeField(\"\(rule_name)_iterator_key\", typeof(string));" &
				"\(sum_indent)var \(storage_name) = \(generator).MakeField(\"\(rule_name)_iterator_ordinal\", typeof(long));" &
				"\(sum_indent)\(generator).CopyField(\(initial.storage_name), \(storage_name));" &
				"\(sum_indent)var \(iterator_instance) = \(generator).MakeField(\"\(rule_name)_iterator\", typeof(MergeIterator));" &
				"\(sum_indent)var \(iterator_state) = \(generator).DefineState();" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);" &
				# Create an array for the length of the input and load all the inputs.
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, \(num_inputs));" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Newarr, typeof(IAttributeNames));" &
				input_loads &
				# Create a block for the default dispatcher and put a delegate on the stack.
				"\(sum_indent)\(generator).CreateBlockEntry<MergeIterator.KeyDispatch>(() => {" &
				"\(sum_indent)\t\(generator).LoadIteratorData(\(iterator_instance), \(iterator_key), \(iterator_ordinal));" &
				dispatch_code &
				"\(sum_indent)});" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Newobj, typeof(MergeIterator).GetConstructors()[0]);" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Stfld, \(iterator_instance).Field);" &
				# Load all the special dispatchers.
				add_cases &
				# Create a re-entry point for the end of input (i.e., the iterator returning).
				"\(sum_indent)\(iterator_instance).Load(\(generator));" &
				"\(sum_indent)\(generator).GenerateConsumeResult(null);" &
				"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Callvirt, typeof(MergeIterator).GetMethod(\"Notify\"));" &
				# Invoke the iterator and prepare all the remaining states.
				"\(sum_indent)\(generator).SlotSleep(\(iterator_instance));" &
				"\(sum_indent)\(generator).FlushBlocks();" &
				"\(sum_indent)\(generator).MarkState(\(iterator_state));" &
				"\(sum_indent)\(generator).EraseField(\(iterator_instance));" &
				code

			dispatch_code : default_dispatcher.gen_gen(
				indent : sum_indent & "\t",
				code :
					"\(sum_indent)\(default_dispatcher.extra_indent)\t\(generator).CopyField(\(default_dispatcher.storage_name), \(storage_name));" &
					"\(sum_indent)\(default_dispatcher.extra_indent)\t\(generator).SetState(\(iterator_state));" &
					"\(sum_indent)\(default_dispatcher.extra_indent)\t\(generator).SlotSleep(\(iterator_instance));"
					)

			input_loads :
				For input : inputs, index : Ordinal
				Reduce acc &
					"\(sum_indent)if (!typeof(IAttributeNames).IsAssignableFrom(\(input.value.storage_name).BackingType)) throw new System.InvalidOperationException();" &
					"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Dup);" &
					"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, \(index - 1));" &
					"\(sum_indent)\(input.value.storage_name).Load(\(generator));" &
					"\(sum_indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Stelem);"
				With acc : ""

			add_cases :
				For case : cases
				Reduce
					acc &
					case.gen_gen(indent : sum_indent)
					With acc : ""
		}

		base_case_tmpl +: {
			gen_gen : Template {
				indent ?:
				sum_indent : indent & action.extra_indent & "\t"
				load_key : "\(indent)\t\(generator).LoadIteratorData(\(iterator_instance), \(iterator_key), \(iterator_ordinal));"
				base_code :
					"\(sum_indent)\(generator).CopyField(\(action.storage_name), \(storage_name));" &
					"\(sum_indent)\(generator).SetState(\(iterator_state));" &
					"\(sum_indent)\(generator).SlotSleep(\(iterator_instance));"
				value ?:
			}
		}
		literal_case_tmpl +: {
			gen_gen +: {
				value :
					"\(indent)\(generator).CreateIteratorBlock(\(iterator_instance), \"\(name)\", () => {" &
					load_key &
					action.gen_gen(indent : indent & "\t", code : base_code) &
					"\(indent)});"
			}
		}
		remote_field_case_tmpl +: {
			gen_gen +: {
				value :
					"\(indent)\(generator).CreateIteratorBlock(\(iterator_instance), \(field).\(name_field).ToString(), () => {" &
					load_key &
					action.gen_gen(indent : indent & "\t", code : base_code) &
					"\(indent)});"
			}
		}
		list_case_tmpl +: {
			current_element : Id
			gen_gen +: {
				value :
					"\(indent)foreach (var \(current_element) in \(field)) \(generator).CreateIteratorBlock(\(iterator_instance), \(current_field_name).\(name_field).ToString(), () => {" &
					load_key &
					action.gen_gen(indent : indent & "\t", code : base_code) &
					"\(indent)});"
			}
		}

		current_name : codegen.gen_tmpl { storage_name : iterator_key }
		current_ordinal : codegen.gen_tmpl { storage_name : iterator_key }
	}
}
# Generate hideously complicated flows in the compiler's code generation routines.
codegen : compiler_lib.codegen_tmpl {
	# This is the base template for all of the code generation. The `gen_gen`
	# system is described in the compiler design manual.
	gen_tmpl +: {
		# Keeping tabbing correct in the code generator, but the OCD makes the
		# final result intelligible. This attribute should be the tabbing that
		# should be applied to `code` in addition to `indent` to make it appear at
		# the correct indentation. It can be thought of as the indentation
		# difference between the starting indentation and the indentation of the
		# callback.
		extra_indent ?:
		storage_name : Id
		gen_gen : Template {
			# The indentation of the code.
			indent ?:
			# The code to execute when this operation is completed and its value is
			# stored in a variable with the name of the value in `storage_name`.
			code ?:
			value : code
		}
	}
	# This nasty customer does a fold over a list of syntax elements. It
	# accomplishes this using the painfully obtuse `Generator.Fold` function.
	fold_others +: {
		extra_indent : initial.extra_indent & "\t"
		fold_name : "\(Id)_left"
		argument_list : "\(generator), " &
			(If target_flavour.accumulate_flavour.has_cache Then lookup_cache & ", " Else "") &
			(target_flavour.accumulate_flavour.call_site {}).value

		gen_gen +: {
			sum_indent : indent & initial.extra_indent
			value :
				initial.gen_gen(
					indent : indent,
					code :
						"\(sum_indent)_generator.Fold((LoadableValue) \(initial.storage_name), \(field), (\(Id)_index, \(Id)_item, \(fold_name), \(Id)_block) => \(Id)_item.Generate(\(argument_list)\(Id)_block), (\(storage_name)) => {\(code)\(sum_indent)});"
						)
		}
		parameters : {
			accumulator : codegen.gen_tmpl {
				extra_indent : ""
				storage_name : fold_name
			}
		}
	}
	lookup_cached +: {
		extra_indent : ""
		gen_gen +: {
			value : "\(indent)var \(storage_name) = \(lookup_cache)[\(generation_environment).Lookup(null, \(field).Select((s) => s.ToString()))];\(code)"
		}
	}
	# This changes the value of parameters by renaming them, then restoring the names.
	mask_parameters +: {
		storage_name : action.storage_name
		extra_indent : For parameter : parameters Reduce parameter.extra_indent & acc With acc : action.extra_indent
		parameter_indents : For parameter_name : Name, parameter : parameters, parameter_pos : Ordinal
			Select parameter_name :
				(For prev_parameter : parameters, prev_parameter_pos : Ordinal
				Where prev_parameter_pos < parameter_pos
				Reduce acc & prev_parameter.extra_indent
				With acc : "")

		gen_gen +: {
			sum_indent : indent & extra_indent
			base_code : For parameter_name : Name, parameter : parameters
				Reduce
					"\(sum_indent)var \(Id)_\(parameter_name) = \(parameter_name);" &
					"\(sum_indent)\(parameter_name) = \(parameters.storage_name);" &
					acc &
					"\(sum_indent)\(parameter_name) = \(Id)_\(parameter_name);"
					With acc : action.gen_gen(code : code, indent : sum_indent)

			value :
				For parameter : parameters, parameter_indent : parameter_indents
				Reduce parameter.gen_gen(code : acc, indent : indent & action.extra_indent & parameter_indent)
				With acc : base_code
		}
	}
	not_implemented +: {
		extra_indent : ""
		storage_name : "null"
		gen_gen +: {
			value : "\(indent)throw new System.NotImplementedException(\"\(pretty_name) not implemented\");"
		}
	}
	other_code +: {
		extra_indent : "\t"
		argument_list :"\(generator), " &
			(If target_flavour.non_accumulate_flavour.has_cache Then lookup_cache & ", " Else "") &
			(target_flavour.non_accumulate_flavour.call_site {}).value

		gen_gen +: {
			value :
				"\(indent)\(field).Generate(\(argument_list)(\(storage_name)) => {\(code)\(indent)});"
		}
	}
	parameter +: {
		extra_indent : ""
		storage_name : name
		gen_gen +: {
			value :
				"\(indent)if (\(name) == null) throw new System.InvalidOperationException(\"\(error_message)\");" &
				code
		}
	}
	prepare_lookup_cache +: {
		extra_indent : in.extra_indent & specials.extra_indent & "\t"
		storage_name : in.storage_name
		parent_context : Lookup parameters.context In Container
		parent_lookup_cache : Lookup lookup_cache In Container
		parameters : { context : specials.context }
		lookup_cache : Id
		gen_gen +: {
			sum_indent : indent & specials.extra_indent
			value :
				specials.gen_gen(
					indent : indent,
					code :
						"\(sum_indent)\(name).GenerateLookupCache(\(generator), \(specials.initial_cache), \(parameters.source_reference.storage_name), \(specials.context.storage_name), (\(lookup_cache)) => {" &
						in.gen_gen(indent : sum_indent & "\t", code : code) &
						"\(sum_indent)});"
					)
		}
		lookup_special_tmpl +: {
			extra_indent : ""
			initial_cache ?:
			context ?:
			gen_gen : Template {
				code ?:
				indent ?:
			}
		}
		no_specials +: {
			initial_cache : parent_lookup_cache
			context : parent_context
			gen_gen +: {
				value : code
			}
		}
		specials_from_definitions +: {
			extra_indent : "\t"
			initial_cache : Id
			context : codegen.gen_tmpl {
				extra_indent : ""
			}
			# This is here so that our call to the generate of the named elements
			# uses the original lookup context.
			parameters : { context : parent_context }
			# Restore the lookup cache for the child definitions
			lookup_cache : parent_lookup_cache
			argument_list :"\(generator), " &
				(If target_flavour.non_accumulate_flavour.has_cache Then lookup_cache & ", " Else "") &
				(target_flavour.non_accumulate_flavour.call_site {}).value

			gen_gen +: {
				value :
					"\(indent)var \(Id)_frame = \(generator).MakeField(\"anon_frame\", typeof(Frame));" &
					"\(indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);" &
					"\(indent)\(generator).GenerateNextId();" &
					"\(indent)\(parameters.source_reference.storage_name).Load(\(generator));" &
					"\(indent)\(parameters.self_frame.storage_name).Load(\(generator));" &
					"\(indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Newobj, typeof(Frame).GetConstructors()[0]);" &
					"\(indent)\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Stfld, \(Id)_frame.Field);" &
					"\(indent)\(generator).Fold(\(parent_lookup_cache), \(field), (\(Id)_index, \(Id)_item, \(Id)_cache, \(Id)_block) =>" &
					"\(indent)\t\(Id)_item.Generate(\(argument_list)(\(Id)_result) => {" &
					"\(indent)\t\tvar \(Id)_new_cached = new LookupCache(\(Id)_cache);" &
					"\(indent)\t\t\(Id)_new_cached[\(name).Lookup(null, System.Linq.Enumerable.Repeat(\(Id)_item.name.ToString(), 1))] = \(Id)_result;" &
					"\(indent)\t\t\(Id)_frame.Load(\(generator));" &
					"\(indent)\t\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldstr, \(Id)_item.name.ToString());" &
					"\(indent)\t\t\(Id)_result.Load(\(generator));" &
					"\(indent)\t\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Call, typeof(Frame).GetMethod(\"set_Item\"));" &
					"\(indent)\t\t\(Id)_block(\(Id)_new_cached);" &
					"\(indent)}), (\(initial_cache)) => {" &
					"\(indent)\tvar \(context.storage_name) = \(generator).MakeField(\"subcontext\", typeof(Context));" &
					"\(indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);" &
					"\(indent)\t\(Id)_frame.Load(\(generator));" &
					"\(indent)\t\(parent_context.storage_name).Load(\(generator));" &
					"\(indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Call, typeof(Context).GetMethod(\"Prepend\"));" &
					"\(indent)\t\(generator).Builder.Emit(System.Reflection.Emit.OpCodes.Stfld, \(context.storage_name).Field);" &
					code &
					"\(indent)});"
			}
		}
	}
	push_source_reference +: {
		storage_name : in.storage_name
		extra_indent : ""
		parent_source_reference : Lookup parameters.source_reference.storage_name In Container
		new_source_reference : Id
		parameters : {
			source_reference : codegen.gen_tmpl {
				extra_indent : ""
				storage_name : new_source_reference
			}
		}
		gen_gen +: {
			value :
				"\(indent)var \(new_source_reference) = \(generator).PushSourceReference(this, \(parent_source_reference));" &
				in.gen_gen(indent : indent, code : code)
		}
	}
	type_dispatch_tmpl +: {
		callback : Id & "_code"
		reference_type ?:
		choice_tmpl +: {
			target_type ?:
		}

		gen_gen +: {
			sum_indent ?:

			choice_block :
				For choice : choices
					Reduce
						"if (\(reference_type) == \(choice.target_type)) {" &
						choice.action.gen_gen(
							indent : sum_indent & "\t",
							code : "\(sum_indent)\(choice.action.extra_indent)\t\(callback)(\(choice.action.storage_name));"
						) & "\(sum_indent)} else " & acc
					With acc :
						"{" &
						default_action.gen_gen(
							indent : sum_indent & "\t",
							code : "\(sum_indent)\(default_action.extra_indent)\t\(callback)(\(default_action.storage_name));"
							) & sum_indent & "}"
			lift_code :
				"\(sum_indent)Generator.ParameterisedBlock<LoadableValue> \(callback) = (\(storage_name)) => {\(code)\(sum_indent)};"
		}
	}
	type_dispatch +: {
		extra_indent : "\t" & of.extra_indent
		reference_type : of.storage_name & ".BackingType"
		choice_tmpl +: {
			target_type : "typeof(\(type.real_type))"
		}
		converted_result : codegen.gen_tmpl {
			extra_indent : ""
			storage_name : of.storage_name
		}

		gen_gen +: {
			sum_indent : indent & of.extra_indent
			value : of.gen_gen(
				indent : indent,
				code : lift_code & sum_indent & choice_block
			)
		}
	}
	type_dispatch_parsed +: {
		extra_indent : "\t"
		reference_type : "\(field).TypeId"
		choice_tmpl +: {
			target_type : type.union_type
		}

		gen_gen +: {
			sum_indent : indent
			value : lift_code & sum_indent & choice_block
		}
	}

	flavour_complex_tmpl : Template {
		parameter_names ?:
		parameter_str :
			For parameter_name : parameter_names
				Reduce "\(acc)LoadableValue _\(parameter_name), "
				With acc :
					"Generator _generator, " &
					(If has_cache Then "LookupCache _cache, " Else "")
		parameter_definitions :
			For parameter_name : parameter_names
			Select parameter_name : gen_tmpl {
				extra_indent : ""
				storage_name : "_" & parameter_name
			}
		call_site : Template {
			parameter_lookups ?:
			value :
				For x : parameter_lookups
					Reduce acc & x.storage_name & ", "
					With acc : ""
		}
	}
	flavour_aware : flavour_complex_tmpl {
		has_cache : True
		parameter_names : [ $source_reference, $context, $self_frame, $container_frame ]
		call_site +: {
			parameter_lookups : [ parameters.source_reference, parameters.context, parameters.self_frame, parameters.container_frame ]
		}
		accumulate_flavour : flavour_aware_accumulate
		non_accumulate_flavour : flavour_aware
	}
	flavour_aware_accumulate : flavour_complex_tmpl {
		has_cache : True
		parameter_names : [ $source_reference, $context, $self_frame, $container_frame, $accumulator ]
		call_site +: {
			parameter_lookups : [ parameters.source_reference, parameters.context, parameters.self_frame, parameters.container_frame, parameters.accumulator ]
		}
		accumulate_flavour : flavour_aware_accumulate
		non_accumulate_flavour : flavour_aware
	}
	flavour_accumulate : flavour_complex_tmpl {
		has_cache : False
		parameter_names : [ $source_reference, $accumulator ]
		call_site +: {
			parameter_lookups : [ parameters.source_reference, parameters.accumulator ]
		}
		accumulate_flavour : flavour_accumulate
		non_accumulate_flavour : Null
	}
}

# The compiler!
compiler : compiler_lib.language_tmpl {
	# Since each syntax element corresponds to a class, it should know how to
	# generate a class with all the appropriate methods.
	syntax_element +: {
		class_extra : ""
		indent : "\n\t\t"
		class_name : group_name & "_" & rule_name
		parser_gen :
			"\tinternal static bool ParseRule_\(rule_name)(ref ParserPosition _position, out \(group_name) _result) {\n" &
			"\t\tif(_position.CheckCache<\(class_name), \(group_name)>(out _result)) return _result != null;\n" &
			"\t\tint _start_index = _position.Index;\n" &
			"\t\tvar _obj = new \(class_name)();\n" &
			"\t\t_obj.FileName = _position.Parser.FileName;\n" &
			"\t\t_obj.StartRow = _position.Row;\n" &
			"\t\t_obj.StartColumn = _position.Column;\n" &
			"\t\t_position.TraceEnter(\"\(group_name):\(rule_name)\");\n" &
			pattern.parser_gen & "\n\t}\n"

		current_environment : "_environment"
		environment_methods : environment_flavour.method_gen {}

		current_type : "_type"
		type_assurance : If is_typeable
			Then "\tpublic override void EnsureType(ErrorCollector collector, Type _type) {\(ensure_type_is.value)\n\t}\n"
			Else ""
		type_demands : If environment_flavour.enabled
			Then "\tinternal override void MakeTypeDemands(ErrorCollector collector) {\n" &
				(For field : Name, types : type_demand
					Reduce "\(ensure_acc)\t\tif (\(field) != null) \(field).EnsureType(collector, " &
						(For t : types Reduce acc & " | " & t.union_type With acc : "0") &
						");\n"
					With ensure_acc : "") &
				(For field : Name, types : type_demand_all
					Reduce "\(ensure_acc)\t\tif (\(field) != null) foreach (var _item in \(field)) _item.EnsureType(collector, " &
						(For t : types Reduce acc & " | " & t.union_type With acc : "0") &
						");\n"
					With ensure_acc : "") &
				"\t}\n"
			Else ""

		generator : "_generator"
		generation_environment : "Environment"
		lookup_cache : If !(generation_flavour Is Null) && generation_flavour.has_cache Then "_cache" Else Null
		parameters : If generation_flavour Is Null Then Null Else generation_flavour.parameter_definitions
		code_gen: If generation_flavour Is Null
			Then ""
			Else
				("\tpublic override void Generate(" &
					generation_flavour.parameter_str &
					"Generator.ParameterisedBlock<LoadableValue> _final_block) {" &
					code_value.gen_gen(indent : default_indent, code : "\(indent)\(code_value.extra_indent)_final_block(\(code_value.storage_name));") &
					"\n\t}\n")

		class_gen :
			"internal class \(class_name) : \(group_name) {\n" &
			"\tpublic override string PrettyName { get { return \"\(pretty_name)\"; } }\n" &
			pattern.class_gen &
			environment_methods.value &
			type_assurance &
			type_demands &
			code_gen &
			class_extra &
			"\tinternal \(class_name) Clone() {\n" &
			"\t\tvar _obj = new \(class_name)();\n" &
			common_field_copy_instance & pattern.copy_instance &
			"\t\treturn _obj;\n\t}\n}\n"

		parse_complete : Template {
			ok ?:
			value :
				"\(indent)_position.Cache<\(class_name)>(_start_index, \(If ok Then "_obj" Else "null"));" &
				"\(indent)_position.TraceExit(\"\(group_name):\(rule_name)\", \(If ok Then "true" Else "false"));" &
				(If ok
					Then "\(indent)_obj.EndRow = _position.Row;\(indent)_obj.EndColumn = _position.Column;\(indent)_result = (\(group_name))_obj;\(indent)return true;"
					Else "\(indent)_result = null;\(indent)return false;")
		}
	}
	# Generates the super class for a syntax group and all the appropriate method stubs.
	syntax_group +: {
		super_class_extra : ""
		common_field_class_gen : For field : expanded_common Reduce acc & field.class_gen With acc : ""
		common_field_copy_instance : For field : expanded_common Reduce acc & field.copy_instance With acc : static_copy_instance

		parser_gen :
			For rule : expanded_rules
			Where rule.is_real_element
			Reduce acc & rule.parser_gen
			With acc : ""
		parse_base : If include_base_parser Then
			"\tinternal static bool ParseRule_Base(ref ParserPosition position, out \(group_name) result) {\n" &
			"\t\tposition.TraceEnter(\"\(group_name)\");\n" &
			"\t\tif(position.CheckCache<\(group_name)>(\"\(group_name)\", out result)) return result != null;\n" &
			"\t\tParserPosition slave_position;\n" &
			"\t\tvar start_index = position.Index;\n" &
			"\t\tposition.Update(\"any \(group_name)\", \"\(group_name)\");" &
			(For rule : expanded_rules, rule_name : Name
				Where rule.is_real_element
				Reduce acc &
					"\t\tslave_position = position.Clone();\n" &
					"\t\tif (ParseRule_\(rule_name)(ref slave_position, out result)) {\n" &
					"\t\t\tposition = slave_position;\n" &
					"\t\t\tposition.TraceExit(\"\(group_name)\", true);\n" &
					"\t\t\tposition.Cache<\(group_name)>(\"\(group_name)\", start_index, result);\n" &
					"\t\t\treturn true;\n\t\t}\n"
				With acc : "") &
			"\t\tresult = null;\n" &
			"\t\tposition.TraceExit(\"\(group_name)\", false);\n" &
			"\t\tposition.Cache<\(group_name)>(\"\(group_name)\", start_index, null);\n" &
			"\t\treturn false;\n\t}\n"
			Else ""

		parse_alternates : For alternate_rules : alternatives, alternate_name : Name
			Reduce
				outer_acc &
				"\tinternal static bool ParseRule_\(alternate_name)(ref ParserPosition position, out \(group_name) result) {\n" &
				"\t\tposition.TraceEnter(\"\(alternate_name)\");\n" &
				"\t\tif(position.CheckCache<\(group_name)>(\"\(group_name).\(alternate_name)\", out result)) return result != null;\n" &
				"\t\tParserPosition slave_position;\n" &
				"\t\tvar start_index = position.Index;\n" &
				"\t\tposition.Update(\"\(alternate_name)\", \"\(group_name)\");\n" &
				(For rule_name : Name, rule : expanded_rules
					Where (For rule_alts : rule.alternatives, rule_alt_name : Name Where rule_alt_name == alternate_name Reduce True With junk_acc : False)
					Reduce acc &
						"\t\tslave_position = position.Clone();\n" &
						"\t\tif (ParseRule_" &
						(If rule.is_real_element Then rule_name Else rule.alternate_name) &
						"(ref slave_position, out result)) {\n" &
						"\t\t\tposition = slave_position;\n" &
						"\t\t\tposition.TraceExit(\"\(group_name):\(alternate_name)\", true);\n" &
						"\t\t\tposition.Cache<\(group_name)>(\"\(group_name).\(alternate_name)\", start_index, result);\n" &
						"\t\t\treturn true;\n\t\t}\n"
					With acc : "") &
				"\t\tresult = null;\n" &
				"\t\tposition.TraceExit(\"\(group_name):\(alternate_name)\", false);\n" &
				"\t\tposition.Cache<\(group_name)>(\"\(group_name).\(alternate_name)\", start_index, null);\n" &
				"\t\treturn false;\n\t}\n"
			With outer_acc : ""

		code_gen: If generation_flavour Is Null
			Then ""
			Else
				"\tpublic abstract void Generate(\(generation_flavour.parameter_str)Generator.ParameterisedBlock<LoadableValue> _block);\n"

		value : For rule : expanded_rules
			Where rule.is_real_element
			Reduce acc & rule.class_gen
			With acc : "internal abstract class \(group_name) : \(environment_flavour.class_name)\(If is_typeable Then ", ITypeableElement" Else "") {\n" &
				(If is_typeable Then "\tpublic abstract void EnsureType(ErrorCollector collector, Type _type);\n" Else "") &
				common_field_class_gen &
				super_class_extra &
				parse_base &
				parse_alternates &
				parser_gen &
				code_gen &
				"}\n"
	}
	# Defines a parser for a CLI-compliant name.
	cli_identifier : Template parser.sequence {
		of : [
			parser.char_class {
				classes : [
					letter_lower,
					letter_modifier,
					letter_other,
					letter_title,
					letter_upper,
					number_letter
				]
			},
			parser.many {
				of : parser.char_class {
					classes : [
						letter_lower,
						letter_modifier,
						letter_other,
						letter_title,
						letter_upper,
						mark_combining,
						mark_nonspace,
						number_decimal,
						number_letter,
						other_format,
						punctuation_connector
					]
				}
			}
		]
	}

	# For rule groups, some require special handling not inferable from the
	# compiler, so the `super_class_extra` and `class_extra` attributes provide
	# that content.
	rule_groups +: {
		fricassee_merge_input +: {
			super_class_extra : "\tinternal void AddMask(ErrorCollector collector, Environment environment) { environment.AddMask(name.ToString(), this); }\n"
		}
		named_definition +: {
			super_class_extra : "\tinternal void AddMask(ErrorCollector collector, Environment environment) { environment.AddMask(name.ToString(), this); }\n"
		}
		identifier +: {
			rules +: {
				literal_identifier +: {
					class_extra : "\tpublic override string ToString() { return name.ToString(); }\n"
				}
			}
		}
		type +: {
			super_class_extra : "\tinternal abstract Type TypeId { get; }\n\tinternal abstract Type CastableFrom { get; }\n"
			type_element +: {
				castable_from_type_bits : For t : castable_from Reduce acc & " | " & t.union_type With acc : type.union_type
				class_extra : "\tinternal override Type TypeId { get { return \(type.union_type); } }\n\tinternal override Type CastableFrom { get { return \(castable_from_type_bits); }}\n"
			}
		}
		expression +: {
			rules +: {
				# This is a special expression to call methods in the CLI libraries.
				xinvoke : Template expression_tmpl {
					level : 19
					pretty_name : "invoke CLI method"
					pattern : parser.sequence {
						of : [
							parser.exact { word : "XInvoke" },
							space { mandatory : True },
							parser.accumulate_string {
								field : "type_name"
								in : parser.many {
									nonempty : True
									accumulate : True
									separator : parser.single { char : "." }
									of : cli_identifier { }
								}
							},
							space { mandatory : True },
							parser.accumulate_string {
								field : "method_name"
								accumulate: True
								in : cli_identifier { }
							},
							space { },
							parser.exact { word : "(" },
							parser.accumulate_list {
								type : "expression"
								field : "arguments"
								in : parser.many_word {
									separator_word : ","
									of : parser.sequence {
										of : [
											space { preferred : True },
											parser.other {
												type : "expression"
												alternate : "expression0"
												field : Null
											},
											space { }
										]
									}
								}
							},
							parser.exact { word : ")" }
						]
					}
					class_extra : "\tprivate System.Collections.Generic.List<System.Reflection.MethodInfo> Methods = new System.Collections.Generic.List<System.Reflection.MethodInfo>();\n"
					apply_environment_to : [
						environment.list_of { field : "arguments" },
						environment.application_action {
							class_gen : ""
							value :
								"\t\tReflectMethod(_collector, this, type_name.ToString(), method_name.ToString(), arguments.Count, Methods);\n"
						}
					]
					ensure_type_is : {
						value : "\(indent)CheckReflectedMethod(collector, this, Methods, arguments, \(current_type));"
					}
				}
			}
		}
	}
	value : "using System.Linq;\nnamespace Flabbergast {\n" & (For group : expanded_groups Reduce acc & group.value With acc : "") & "}"
}
